---
layout: article
title: Examples
description: This is the description used for SEO.
difficulty: beginner
readtime: 3
---


Appwrite Functions is all about flexibility. Behind the simple workflow hides some useful examples that can help you accomplish your goals faster. Take a look at the following.

# Currency conversion API

Here's a currency conversion API that converts from Euros and Indian Rupees to US Dollars. We'll use an external API to get the latest exchange rates and query it using a dependency specific to each runtime.

## Prerequisites

### Node.js
1. Run the following bash command to create a `package.json` file. This file is used to manage your Node.js project's dependencies.
```bash
npm init -y
```
2. Install the `undici` library. This library includes a `fetch` function that you can use to make HTTP requests. 
    
```bash
npm install undici
```
3. Finally, add `npm install` to your function's build commands in the Appwrite Console.

- **PHP**
  - Run the following bash command to create a `composer.json` file. This file is used to manage your PHP project's dependencies.
    ```bash
    composer init -y
    ```
  - Install the `guzzlehttp/guzzle` library. This library includes a `get` function that you can use to make HTTP requests.
    ```bash
    composer require guzzlehttp/guzzle
    ```
  - Finally, add `composer install` to your function's build commands in the Appwrite Console.

- **Python**
  - Run the following bash command to create a `requirements.txt` file. This file is used to manage your Python project's dependencies.
    ```bash
    touch requirements.txt
    ```
  - Install the `requests` library. This library includes a `get` function that you can use to make HTTP requests.
    ```bash
    echo "requests" >> requirements.txt
    pip install -r requirements.txt
    ```
  - Finally, add `pip install -r requirements.txt` to your function's build commands in the Appwrite Console.

- **Dart**
  - Create a `pubspec.yaml` file with the following contents. This file is used to manage your Dart project's dependencies.
    ```yaml
    name: appwrite_function
    description: Appwrite Function
    version: 1.0.0
    environment:
      sdk: '>=2.12.0 <3.0.0'
    ```
  - Install the `http` library. This library includes a `get` function that you can use to make HTTP requests.
    ```bash
    pub install http
    ```
  - Finally, add `pub get` to your function's build commands in the Appwrite Console.

- **Ruby**
  - Create a `Gemfile` file with the following contents. This file is used to manage your Ruby project's dependencies.
    ```ruby
    source 'https://rubygems.org'
    ```
  - Install the `httparty` library. This library includes a `get` function that you can use to make HTTP requests.
    ```bash
    echo "gem 'httparty'" >> Gemfile
    bundle install
    ```
  - Finally, add `bundle install` to your function's build commands in the Appwrite Console.

## Code
```js
import { fetch } from 'undici';

export default async function ({ req, res }) {
  if (req.path === '/eur') {
    const amountInEuros = Number(req.query.amount);
    const response = await fetch('https://api.exchangerate.host/latest?base=EUR&symbols=USD');
    const data = await response.json();
    const amountInDollars = amountInEuros * data.rates.USD;
    return res.send(amountInDollars.toString());
  }

  if (req.path === '/inr') {
    const amountInRupees = Number(req.query.amount);
    const response = await fetch('https://api.exchangerate.host/latest?base=INR&symbols=USD');
    const data = await response.json();
    const amountInDollars = amountInRupees * data.rates.USD;
    return res.send(amountInDollars.toString());
  }

  return res.send('Invalid path');
};
```
```php
<?php

require(__DIR__ . '/../vendor/autoload.php');

use Appwrite\Client;
use Appwrite\Exception;
use Appwrite\Services\Database;
use GuzzleHttp\Client as GuzzleClient;

return function ($context) {
    $client = new GuzzleClient();

    if ($context->req->path === '/eur') {
        $amountInEuros = floatval($context->req->query['amount']);
        $response = $client->get('https://api.exchangerate.host/latest?base=EUR&symbols=USD');
        $data = $response->json();
        $amountInDollars = $amountInEuros * $data['rates']['USD

'];
        return $context->res->send((string) $amountInDollars);
    }

    if ($context->req->path === '/inr') {
        $amountInRupees = floatval($context->req->query['amount']);
        $response = $client->get('https://api.exchangerate.host/latest?base=INR&symbols=USD');
        $data = $response->json();
        $amountInDollars = $amountInRupees * $data['rates']['USD'];
        return $context->res->send((string) $amountInDollars);
    }

    return $context->res->send('Invalid path');
};
```
```python
import requests

def handler(context):
    if context['req']['path'] == '/eur':
        amount_in_euros = float(context['req']['query']['amount'])
        response = requests.get('https://api.exchangerate.host/latest?base=EUR&symbols=USD')
        data = response.json()
        amount_in_dollars = amount_in_euros * data['rates']['USD']
        return str(amount_in_dollars)

    if context['req']['path'] == '/inr':
        amount_in_rupees = float(context['req']['query']['amount'])
        response = requests.get('https://api.exchangerate.host/latest?base=INR&symbols=USD')
        data = response.json()
        amount_in_dollars = amount_in_rupees * data['rates']['USD']
        return str(amount_in_dollars)

    return 'Invalid path'
```
```dart
import 'dart:convert';
import 'package:http/http.dart' as http;

Future<String> handler(Map<String, dynamic> context) async {
  if (context['req']['path'] == '/eur') {
    double amountInEuros = double.parse(context['req']['query']['amount']);
    final response = await http.get(Uri.parse('https://api.exchangerate.host/latest?base=EUR&symbols=USD'));
    final data = json.decode(response.body);
    double amountInDollars = amountInEuros * data['rates']['USD'];
    return amountInDollars.toString();
  }

  if (context['req']['path'] == '/inr') {
    double amountInRupees = double.parse(context['req']['query']['amount']);
    final response = await http.get(Uri.parse('https://api.exchangerate.host/latest?base=INR&symbols=USD'));
    final data = json.decode(response.body);
    double amountInDollars = amountInRupees * data['rates']['USD'];
    return amountInDollars.toString();
  }

  return 'Invalid path';
}
```
```ruby
require 'httparty'

def handler(context)
  if context['req']['path'] == '/eur'
    amount_in_euros = context['req']['query']['amount'].to_f
    response = HTTParty.get('https://api.exchangerate.host/latest?base=EUR&symbols=USD')
    data = JSON.parse(response.body)
    amount_in_dollars = amount_in_euros * data['rates']['USD']
    return amount_in_dollars.to_s
  end

  if context['req']['path'] == '/inr'
    amount_in_rupees = context['req']['query']['amount'].to_f
    response = HTTParty.get('https://api.exchangerate.host/latest?base=INR&symbols=USD')
    data = JSON.parse(response.body)
    amount_in_dollars = amount_in_rupees * data['rates']['USD']
    return amount_in_dollars.to_s
  end

  'Invalid path'
end
```
{% multicode %}

# Custom URL Shortener {% #url-shortener) %}

Here's a custom URL shortener API that uses a Redis database to generate and store short URLs. 
You'll need to set up a Redis instance and use a Redis client to interact with it.

## Prerequisites

### Node.js
Make sure you have Redis installed and running on your system.
Install the `ioredis` library, a Redis client for Node.js.
```bash
npm install ioredis
```
Finally, add `npm install` to your function's build commands in the Appwrite Console.

### PHP
1. Make sure you have Redis installed and running on your system.
2. Install the `predis/predis` library, a Redis client for PHP.
```bash
composer require predis/predis
```
3. Finally, add `composer install` to your function's build commands in the Appwrite Console.

### Python
1. Make sure you have Redis installed and running on your system.
2. Install the `redis` library, a Redis client for Python.
```bash
pip install redis
```
3. Finally, add `pip install redis` to your function's build commands in the Appwrite Console.

### Dart
1. Make sure you have Redis installed and running on your system.
2. Install the `pub_redis_client` library, a Redis client for Dart.
```bash
pub global activate pub_redis_client
```
3. Finally, add `pub global run pub_redis_client:install` to your function's build commands in the Appwrite Console.

### Ruby
1. Make sure you have Redis installed and running on your system.
2. Install the `redis-rb` library, a Redis client for Ruby.
    ```bash
    echo "gem 'redis-rb'" >> Gemfile
    bundle install
    ```
3. Finally, add `bundle install` to your function's build commands in the Appwrite Console.

## Code

{% multicode %}
```js
import { createClient } from 'ioredis';

export default async function ({ req, res }) {
  const redis = createClient();

  if (req.method === 'POST') {
    const url = req.body.url;
    const shortId = generateShortId();
    await redis.set(shortId, url);
    return res.json({ shortId });
  } else if (req.method === 'GET') {
    const shortId = req.query.shortId;
    const url = await redis.get(shortId);
    if (url) {
      return res.json({ url });
    } else {
      return res.status(404).json({ message: 'URL not found' });
    }
  } else {
    return res.status(405).json({ message: 'Method not allowed' });
  }
}

function generateShortId() {
  // Generate a short ID logic here
}
```
```php
<?php

require(__DIR__ . '/../vendor/autoload.php');

use Appwrite\Client;
use Appwrite\Exception;
use Appwrite\Services\Database;
use Predis\Client as PredisClient;

return function ($context) {
    $redis = new PredisClient();

    if ($context->req->getMethod() === 'POST') {
        $url = $context->req->data['url'];
        $shortId = generateShortId();
        $redis->set($shortId, $url);
        return $context->res->json(['shortId' => $shortId]);
    } elseif ($context->req->getMethod() === 'GET

') {
        $shortId = $context->req->getQuery('shortId');
        $url = $redis->get($shortId);
        if ($url) {
            return $context->res->json(['url' => $url]);
        } else {
            return $context->res->setStatus(404)->json(['message' => 'URL not found']);
        }
    } else {
        return $context->res->setStatus(405)->json(['message' => 'Method not allowed']);
    }
};

function generateShortId()
{
    // Generate a short ID logic here
}
```
```python
import redis

def handler(context):
    r = redis.Redis(host='localhost', port=6379, db=0)

    if context['req']['method'] == 'POST':
        url = context['req']['data']['url']
        short_id = generate_short_id()
        r.set(short_id, url)
        return {'shortId': short_id}
    elif context['req']['method'] == 'GET':
        short_id = context['req']['query']['shortId']
        url = r.get(short_id)
        if url:
            return {'url': url.decode('utf-8')}
        else:
            return {'message': 'URL not found'}, 404
    else:
        return {'message': 'Method not allowed'}, 405

def generate_short_id():
    # Generate a short ID logic here
```
```dart
import 'dart:convert';
import 'package:pub_redis_client/pub_redis_client.dart';

Future<Map<String, dynamic>> handler(Map<String, dynamic> context) async {
  final redis = await PubRedisClient.connect('redis://localhost:6379/0');

  if (context['req']['method'] == 'POST') {
    final url = context['req']['data']['url'];
    final shortId = generateShortId();
    await redis.set(shortId, url);
    return {'shortId': shortId};
  } else if (context['req']['method'] == 'GET') {
    final shortId = context['req']['query']['shortId'];
    final url = await redis.get(shortId);
    if (url != null) {
      return {'url': url};
    } else {
      return {'message': 'URL not found'};
    }
  } else {
    return {'message': 'Method not allowed'};
  }
}

String generateShortId() {
  // Generate a short ID logic here
}
```
```ruby
require 'redis'

def handler(context)
  r = Redis.new(host: 'localhost', port: 6379, db: 0)

  if context['req']['method'] == 'POST'
    url = context['req']['data']['url']
    short_id = generate_short_id
    r.set(short_id, url)
    { 'shortId' => short_id }
  elsif context['req']['method'] == 'GET'
    short_id = context['req']['query']['shortId']
    url = r.get(short_id)
    if url
      { 'url' => url }
    else
      { 'message' => 'URL not found' }
    end
  else
    { 'message' => 'Method not allowed' }
  end
end

def generate_short_id
  # Generate a short ID logic here
end
```
{% /multicode %}
