---
layout: article
title: Send push notification
description: Send push notification to your users using Appwrite Messaging.
---

You can send, schedule, and manage push notifications to your apps using Appwrite Messaging.
Push notifications can be used to deliver new message notifications, app updates, promotional offers,
and other messages straight to your user's devices.

{% section #add-provider step=1 title="Add provider" %}
Push notifications must be sent through third-party providers, like Apple Push Notification service and Firebase Cloud Messaging.
The push notification APIs for Apple and Android devices can only be accessed through these services.

You must configure these services before you can send your first push notification.

{% cards %}
{% cards_item href="/docs/products/messaging/apns" title="APNS" icon="icon-apple" %}
Configure APNs for push notification to Apple devices.
{% /cards_item %}
{% cards_item href="/docs/products/messaging/fcm" title="FCM" icon="icon-firebase" %}
Configure FCM for push notification to Android and Apple devices.
{% /cards_item %}
{% /cards %}

{% /section %}
{% section #add-targets step=2 title="Add targets" %}
Before sending your first push notification, your application must register itself for push notification,
then provide the device token to Appwrite.

{% tabs %}
{% tabsitem #apple-apns title="APNs for Apple" %}
First, enable push notification in your app.
1. Head to **Apple Developer Member Center** > **Program resources** > **Certificates, Identifiers & Profiles** > **Keys**. The key needs **Apple Push Notification Service** enabled.
1. Create a new key, note down the key ID and download your key.
1. Add push notification capability to your app by clicking your root-level app in XCode > **Signing & Capabilities** > {% icon icon="plus" size="m" /%} Capabilities > Search for **Push Notifications**.

{% only_dark %} ![Authentication Key](/images/docs/messaging/providers/apns/dark/xcode-enable-pn.png) {% /only_dark %} {% only_light %} ![Authentication Key](/images/docs/messaging/providers/apns/xcode-enable-pn.png) {% /only_light %}

First, register for remote notifications in your app delegate's `application(_:didFinishLaunchingWithOptions:)` method.

```swift
func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil
) -> Bool {
    // Register for remote notifications
    UNUserNotificationCenter.current().delegate = self

    let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]
    UNUserNotificationCenter.current().requestAuthorization(
        options: authOptions,
        completionHandler: { granted, error in
            DispatchQueue.main.async {
                if granted {
                    application.registerForRemoteNotifications()
                }
            }
        }
    )

    return true
}
```


Next, create a handler for when the app receives the push notification device token.
```swift
class AppDelegate: NSObject, UIApplicationDelegate {
    func application(
        _ application: UIApplication,
        didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data
    ) {
        // register device
        var token = deviceToken.map { String(format: "%.2hhx", $0) }.joined()
        
        // Save the token to be used later
        UserDefaults.standard.set(token, forKey: "apnsToken")
    }
}
```
Since the token is saved in `UserDefaults`, you can access it from anywhere in your app.
With this saved `apnsToken`, you can create a push target with Appwrite when the user logs in.
Each push target is associated with an account, heres an example with a email password login.
The same logic applies to all types of login methods.
```swift
func login() async {
    do {
        let session = try await account.createEmailPasswordSession(
            email: username,
            password: password
        )

        guard let token = UserDefaults.standard.string(forKey: "apnsToken") else {
            return
        }

        guard let target = try? await account.createPushTarget(
            targetId: ID.unique(),
            identifier: token
        ) else {
            return
        }

        UserDefaults.standard.set(target.id, forKey: "targetId")

        DispatchQueue.main.async {
            self.response = String(describing: session.toMap())
        }
    } catch {
        DispatchQueue.main.async {
            self.response = error.localizedDescription
        }
    }
}
```
{% /tabsitem %}

{% tabsitem #android-fcm title="FCM for Android" %}
Before you can send push notifications using FCM, make sure you'd followed the steps to
[Add Firebase to your Android project](https://firebase.google.com/docs/android/setup).

After adding Firebase to your Android project and adding the `google-services.json` to your project,
initialize Firebase in your main activity and fetch the FCM registration token.

```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate() {
        // ... other logic

        // Initialize Firebase
        FirebaseApp.initializeApp(this)

        // Set the FCM token
        FirebaseMessaging.getInstance().token.addOnCompleteListener(OnCompleteListener { task ->
            if (!task.isSuccessful) {
                Log.w(TAG, "Fetching FCM registration token failed", task.exception)
                return@OnCompleteListener
            }

            // Get new FCM registration token and save it in prefs to be used later.
            val token = task.result
            val prefs = getSharedPreferences("example", MODE_PRIVATE)

            prefs.edit().putString("fcmToken", token).apply()
        })
    }
}
```

Appwrite's push targets are associated with accounts.
Typically, you would create a push target when the user logs in.

For example, when the user logs in with email and password, your app
can register itself as a target after handling the login.

```kotlin
fun onLogin(
    email: String,
    password: String,
    token: String?,
) {
    viewModelScope.launch {
        try {
            // Log in the user
            val session = account.createEmailPasswordSession(
                email,
                password
            )

            // If a token exists, register a push target with Appwrite.
            if (token != null) {
                val target = account.createPushTarget(ID.unique(), token)

                _target.postValue(Event(target))
            }

            _response.postValue(Event(session.toJson()))
        } catch (e: AppwriteException) {
            _error.postValue(Event(e))
        }
    }
}
```

The FCM token that we defined in `sharedPreferenes` will be passed into the `onLogin` handler 
to create the push target.
```kotlin
 binding.login.setOnClickListener{
    viewModel.onLogin(
        binding.email.text.toString(),
        binding.password.text.toString(),
        context
            ?.getSharedPreferences("example", Context.MODE_PRIVATE)
            ?.getString("fcmToken", null) ?: null
    )
}
```

Lastly, because FCM push tokens can change, we need to add a service to handle FCM token
refreshes and update the target with Appwrite Messaging.

Create a new service that extends `FirebaseMessagingService` which handles the event where
the FCM token is updated.

```kotlin
class MessagingService : FirebaseMessagingService() {

    companion object {
        var account: Account? = null
    }

    // This is called when FCM token is updated.
    override fun onNewToken(token: String) {
        super.onNewToken(token)

        val prefs = getSharedPreferences("example", MODE_PRIVATE)

        prefs.edit().putString("fcmToken", token).apply()

        if (account == null) {
            return
        }

        val targetId = prefs.getString("targetId", null)

        runBlocking {
            if (targetId == null) {
                val target = account!!.createPushTarget(ID.unique(), token)

                prefs.edit().putString("targetId", target.id).apply()
            } else {
                account!!.updatePushTarget(targetId, token)
            }
        }
    }
}
```

In your `AndroidManifest.xml`, register this new service.
```xml
<service android:name="io.appwrite.NotificationHandler" android:exported="false">
    <intent-filter>
        <action android:name="com.google.firebase.MESSAGING_EVENT" />
    </intent-filter>
</service>
```
{% /tabsitem %}

{% tabsitem #apple-fcm title="FCM for Apple" %}
Before you can send push notifications using FCM, make sure you'd followed the steps to
[Add Firebase to your iOS project](https://firebase.google.com/docs/ios/setup).

After adding Firebase to your iOS project and adding the `GoogleService-Info.plist` to the root of your project.


Next, add your APNs key to Firebase.
1. Head to **Apple Developer Member Center** > **Program resources** > **Certificates, Identifiers & Profiles** > **Keys**. The key needs **Apple Push Notification Service** enabled.
1. Create a new key, note down the key ID and download your key.
1. In Firebase console, go to *Settings** > **Cloud Messaging** > **APNs authentication key** > click **Upload**. Upload your key here.
1. Add push notification capability to your app by clicking your root-level app in XCode > **Signing & Capabilities** > {% icon icon="plus" size="m" /%} Capabilities > Search for **Push Notifications**.
1. If using SwiftUI, disable swizzling by setting `FirebaseAppDelegateProxyEnabled` to `NO` in your `Info.plist`.

Initialize Firebase in your app delegate's `application(_:didFinishLaunchingWithOptions:)` method,
implement the messaging delegate protocol, and register for remote notifications.

```swift
func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil
) -> Bool {
    // initialize Firebase
    FirebaseApp.configure()

    // Set the messaging delegate
    Messaging.messaging().delegate = self

    // Register for remote notifications
    UNUserNotificationCenter.current().delegate = self

    let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]
    UNUserNotificationCenter.current().requestAuthorization(
        options: authOptions,
        completionHandler: { granted, error in
            DispatchQueue.main.async {
                if granted {
                    application.registerForRemoteNotifications()
                }
            }
        }
    )

    return true
}
```
Your APNS token can change, so you need to handle the token refresh event and update the target with Appwrite Messaging.
Implement `didReceiveRegistrationToken`, which is called when the FCM token is updated.
```swift
func messaging(
    _ messaging: FirebaseMessaging.Messaging,
    didReceiveRegistrationToken fcmToken: String?
) {
    guard let fcmToken = fcmToken else {
        return
    }

    // Save the token to be used later
    UserDefaults.standard.set(fcmToken , forKey: "fcmToken")

    // Get the current Appwrite targetId from UserDefaults
    let targetId = UserDefaults.standard.string(forKey: "targetId")

    Task {
        do {
            _ = try await account.get()
        } catch {
            return // if not logged in, don't update the target
        }

        // if targetId is nil, create a new target
        if targetId == nil {
            let target = try? await account.createPushTarget(
                targetId: ID.unique(),
                identifier: fcmToken
            )

            UserDefaults.standard.set(target?.id , forKey: "targetId")
        } else {
            // if targetId exists for the Appwrite Account, update the target
            _ = try? await account.updatePushTarget(
                targetId: targetId!,
                identifier: fcmToken
            )
        }
    }
}

Since the token is saved in `UserDefaults`, you can access it from anywhere in your app.
With this saved `fcmToken`, you can create a push target with Appwrite when the user logs in.
Each push target is associated with an account, heres an example with a email password login.
The same logic applies to all types of login methods.
```swift
func login() async {
    do {
        let session = try await account.createEmailPasswordSession(
            email: username,
            password: password
        )

        guard let token = UserDefaults.standard.string(forKey: "fcmToken") else {
            return
        }

        guard let target = try? await account.createPushTarget(
            targetId: ID.unique(),
            identifier: token
        ) else {
            return
        }

        UserDefaults.standard.set(target.id, forKey: "targetId")

        DispatchQueue.main.async {
            self.response = String(describing: session.toMap())
        }
    } catch {
        DispatchQueue.main.async {
            self.response = error.localizedDescription
        }
    }
}
```

If you have disabled method swizzling, or you are building a SwiftUI app,
you'll need to explicitly map your APNs token to the FCM registration token. 
Implement the `didRegisterForRemoteNotificationsWithDeviceToken` method to get the device token and save it to FCM.
```swift
func application(
    _ application: UIApplication,
    didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data
) {
    Messaging.messaging().apnsToken = deviceToken
}
``` 
{% /tabsitem %}
{% /tabs %}
{% /section %}

{% section #request-permissions step=3 title="Request permissions" %}
Your app must ask for permission to receive push notification from the user.
Appwrite provides an `OS` class to help simplify the process to handle permissions.

{% tabs %}
{% tabsitem #apple-apns title="Apple with APNs" %}
Before your app can receive push notifications, you need to request the user for permissions.
Appwrite provides a utility to help request permissions to display notificaitons.

```swift
OS.requestPermission(
    application,
    OSPermission.notifications,
    onGranted: {
        // Handle on permission granted
    },
    onDenied: {
        // Handle on permission denied
    }
)
```

{% /tabsitem %}

{% tabsitem #android-fcm title="FCM for Android" %}
First, add `POST_NOTIFICATIONS` to your `AndroidManifest.xml`.

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="YOUR_PACKAGE">
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>
    <!-- ... rest of your manifest -->
```

Then, request permissions to display push notifications in your app.
Appwrite provides a utility to help request permissions.
```kotlin
OS.requestPermission(
    this,                                   // Context
    Manifest.permission.POST_NOTIFICATIONS, // Permission requested
    onGranted = {
        println("Permission granted")       // When permission is granted
    },
    onDenied = {
        println("Permission denied")        // When permission is denied
    },
    onShowRationale = {
        println("Should show rationale")    // Explain why this permission is needed.
    }
)
```
{% /tabsitem %}

{% tabsitem #apple-fcm title="FCM for Apple" %}
Before your app can receive push notifications, you need to request the user for permissions.
Appwrite provides a utility to help request permissions to display notificaitons.

```swift
OS.requestPermission(
    application,
    OSPermission.notifications,
    onGranted: {
        // Handle on permission granted
    },
    onDenied: {
        // Handle on permission denied
    }
)
```

When an FCM registration token is generated, the library uploads the identifier and configuration data to Firebase.
If you wish to give your users the ability to explicitly opt out of sending data to Firebase,
you can disable automatic initialization and manually initialize the library when the user grants permission.

Disable auto-initialization by setting `FirebaseMessagingAutoInitEnabled` to `NO` in your `Info.plist`.
```text
FirebaseMessagingAutoInitEnabled = NO
```

Then, manually initialize the library when the user grants permission.
``` swift
Messaging.messaging().autoInitEnabled = true
```
{% /tabsitem %}
{% /tabs %}

{% /section %}