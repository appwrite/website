---
layout: article
title: Development
description: Master serverless function development with Appwrite. Learn how to write and test functions locally, debug code, and optimize for efficient execution.
---

Appwrite Functions offer a familiar interface if you've developed REST endpoints.
Each function is handled following a request and response pattern.

# Lifecycle {% #life-cycle %}
There is a clear lifecycle for all Appwrite Functions, from beginning to end.
Here's everything that happens during a function execution.

1. The function is invoked.
2. Appwrite passes in request information like headers, body or path through the `context.req` object.
3. The runtime executes the code you defined, you can log through the `context.log()` or `context.error()` methods.
4. Function terminates when you return results using `return context.res.send()`, `return context.res.json()` or similar.

You'll find all of these steps in a simple function like this.

{% multicode %}
```js
import { Client } from 'node-appwrite';

// This is your Appwrite function
// It's executed each time we get a request
export default async ({ req, res, log, error }) => {
  // Why not try the Appwrite SDK?
  //
  // const client = new Client()
  //    .setEndpoint('https://cloud.appwrite.io/v1')
  //    .setProject(process.env.APPWRITE_FUNCTION_PROJECT_ID)
  //    .setKey(process.env.APPWRITE_API_KEY);

  // You can log messages to the console
  log('Hello, Logs!');

  // If something goes wrong, log an error
  error('Hello, Errors!');

  // The `req` object contains the request data
  if (req.method === 'GET') {
    // Send a response with the res object helpers
    // `res.send()` dispatches a string back to the client
    return res.send('Hello, World!');
  }

  // `res.json()` is a handy helper for sending JSON
  return res.json({
    motto: 'Build like a team of hundreds_',
    learn: 'https://appwrite.io/docs',
    connect: 'https://appwrite.io/discord',
    getInspired: 'https://builtwith.appwrite.io',
  });
};
```

```php
require(__DIR__ . '/../vendor/autoload.php');

use Appwrite\Client;
use Appwrite\Exception;

// This is your Appwrite function
// It's executed each time we get a request
return function ($context) {
    // Why not try the Appwrite SDK?
    //
    // $client = new Client();
    // $client
    //     ->setEndpoint('https://cloud.appwrite.io/v1')
    //     ->setProject(getenv('APPWRITE_FUNCTION_PROJECT_ID'))
    //      ->setKey(getenv('APPWRITE_API_KEY'));

    // You can log messages to the console
    $context->log('Hello, Logs!');

    // If something goes wrong, log an error
    $context->error('Hello, Errors!');

    // The `req` object contains the request data
    if ($context->req->method === 'GET') {
        // Send a response with the res object helpers
        // `res.send()` dispatches a string back to the client
        return $context->res->send('Hello, World!');
    }

    // `res.json()` is a handy helper for sending JSON
    return $context->res->json([
        'motto' => 'Build like a team of hundreds_',
        'learn' => 'https://appwrite.io/docs',
        'connect' => 'https://appwrite.io/discord',
        'getInspired' => 'https://builtwith.appwrite.io',
    ]);
};
```

```python
from appwrite.client import Client
import os


# This is your Appwrite function
# It's executed each time we get a request
def main(context):
    # Why not try the Appwrite SDK?
    #
    # client = (
    #     Client()
    #         .set_endpoint("https://cloud.appwrite.io/v1")
    #         .set_project(os.environ["APPWRITE_FUNCTION_PROJECT_ID"])
    #         .set_key(os.environ["APPWRITE_API_KEY"])
    # )

    # You can log messages to the console
    context.log("Hello, Logs!")

    # If something goes wrong, log an error
    context.error("Hello, Errors!")

    # The `context.req` object contains the request data
    if context.req.method == "GET":
        # Send a response with the res object helpers
        # `context.res.send()` dispatches a string back to the client
        return context.res.send("Hello, World!")

    # `context.res.json()` is a handy helper for sending JSON
    return context.res.json({
        "motto": "Build like a team of hundreds_",
        "learn": "https://appwrite.io/docs",
        "connect": "https://appwrite.io/discord",
        "getInspired": "https://builtwith.appwrite.io",
    })
```
```ruby
require "appwrite"

# This is your Appwrite function
# It's executed each time we get a request
def main(context)
  # Why not try the Appwrite SDK?
  #
  # client = Appwrite::Client.new
  # client
  #   .set_endpoint('https://cloud.appwrite.io/v1')
  #   .set_project(ENV['APPWRITE_FUNCTION_PROJECT_ID'])
  #   .set_key(ENV['APPWRITE_API_KEY'])

  # You can log messages to the console
  context.log("Hello, Logs!")

  # If something goes wrong, log an error
  context.error("Hello, Errors!")

  # The `context.req` object contains the request data
  if (context.req.method == "GET")
    # Send a response with the res object helpers
    # `context.res.send()` dispatches a string back to the client
    return context.res.send("Hello, World!")
  end

  # `context.res.json()` is a handy helper for sending JSON
  return context.res.json({
    "motto": "Build like a team of hundreds_",
    "learn": "https://appwrite.io/docs",
    "connect": "https://appwrite.io/discord",
    "getInspired": "https://builtwith.appwrite.io",
  })
end
```
```deno
import { Client } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

// This is your Appwrite function
// It's executed each time we get a request
export default ({ req, res, log, error }: any) => {
  // Why not try the Appwrite SDK?
  //
  // const client = new Client()
  //    .setEndpoint('https://cloud.appwrite.io/v1')
  //    .setProject(Deno.env.get("APPWRITE_FUNCTION_PROJECT_ID"))
  //    .setKey(Deno.env.get("APPWRITE_API_KEY"));

  // You can log messages to the console
  log("Hello, Logs!");

  // If something goes wrong, log an error
  error("Hello, Errors!");

  // The `req` object contains the request data
  if (req.method === "GET") {
    // Send a response with the res object helpers
    // `res.send()` dispatches a string back to the client
    return res.send("Hello, World!");
  }

  // `res.json()` is a handy helper for sending JSON
  return res.json({
    motto: "Build like a team of hundreds_",
    learn: "https://appwrite.io/docs",
    connect: "https://appwrite.io/discord",
    getInspired: "https://builtwith.appwrite.io",
  });
};
```
```dart
import 'dart:async';
import 'package:dart_appwrite/dart_appwrite.dart';

// This is your Appwrite function
// It's executed each time we get a request
Future main(final context) async {
// Why not try the Appwrite SDK?
  //
  // final client = Client()
  //    .setEndpoint('https://cloud.appwrite.io/v1')
  //    .setProject(Platform.environment["APPWRITE_FUNCTION_PROJECT_ID"])
  //    .setKey(Platform.environment["APPWRITE_API_KEY"]);

  // You can log messages to the console
  context.log('Hello, Logs!');

  // If something goes wrong, log an error
  context.error('Hello, Errors!');

  // The `req` object contains the request data
  if (context.req.method == 'GET') {
    // Send a response with the res object helpers
    // `res.send()` dispatches a string back to the client
    return context.res.send('Hello, World!');
  }

  // `res.json()` is a handy helper for sending JSON
  return context.res.json({
    'motto': 'Build like a team of hundreds_',
    'learn': 'https://appwrite.io/docs',
    'connect': 'https://appwrite.io/discord',
    'getInspired': 'https://builtwith.appwrite.io',
  });
}
```
```kotlin
package io.openruntimes.kotlin.src

import io.openruntimes.kotlin.RuntimeContext
import io.openruntimes.kotlin.RuntimeOutput
import io.appwrite.Client
import java.util.HashMap

class Main {
    // This is your Appwrite function
    // It's executed each time we get a request
    fun main(context: RuntimeContext): RuntimeOutput {
        // Why not try the Appwrite SDK?
        // val client = Client()
        //    .setEndpoint("https://cloud.appwrite.io/v1")
        //    .setProject(System.getenv("APPWRITE_FUNCTION_PROJECT_ID"))
        //    .setKey(System.getenv("APPWRITE_API_KEY"))

        // You can log messages to the console
        context.log("Hello, Logs!")

        // If something goes wrong, log an error
        context.error("Hello, Errors!")

        // The `context.req` object contains the request data
        if (context.req.method == "GET") {
            // Send a response with the res object helpers
            // `context.res.send()` dispatches a string back to the client
            return context.res.send("Hello, World!")
        }

        // `context.res.json()` is a handy helper for sending JSON
        return context.res.json(mutableMapOf(
            "motto" to "Build like a team of hundreds_",
            "learn" to "https://appwrite.io/docs",
            "connect" to "https://appwrite.io/discord",
            "getInspired" to "https://builtwith.appwrite.io"
        ))
    }
}
```
```java
package io.openruntimes.java.src;

import io.openruntimes.java.RuntimeContext;
import io.openruntimes.java.RuntimeOutput;
import java.util.HashMap;
import io.appwrite.Client;

public class Main {

    // This is your Appwrite function
    // It's executed each time we get a request
    public RuntimeOutput main(RuntimeContext context) throws Exception {
        // Why not try the Appwrite SDK?
        //
        // Client client = new Client()
        //     .setEndpoint("https://cloud.appwrite.io/v1")
        //     .setProject(System.getenv("APPWRITE_FUNCTION_PROJECT_ID"))
        //     .setKey(System.getenv("APPWRITE_API_KEY"));

        // You can log messages to the console
        context.log("Hello, Logs!");

        // If something goes wrong, log an error
        context.error("Hello, Errors!");

        // The `context.getReq()` object contains the request data
        if (context.getReq().getMethod().equals("GET")) {
            // Send a response with the res object helpers
            // `context.getRes().send()` dispatches a string back to the client
            return context.getRes().send("Hello, World!");
        }

        Map json = new HashMap<>();
        json.put("motto", "Build like a team of hundreds_");
        json.put("learn", "https://appwrite.io/docs");
        json.put("connect", "https://appwrite.io/discord");
        json.put("getInspired", "https://builtwith.appwrite.io");

        // `context.getRes().json()` is a handy helper for sending JSON
        return context.getRes().json(json);
    }
}
```
```swift
import Appwrite
import AppwriteModels
import Foundation

// This is your Appwrite function
// It's executed each time we get a request
func main(context: RuntimeContext) async throws -> RuntimeOutput {
    // Why not try the Appwrite SDK?
    //
    // let client = Client()
    //    .setEndpoint("https://cloud.appwrite.io/v1")
    //    .setProject(ProcessInfo.processInfo.environment["APPWRITE_FUNCTION_PROJECT_ID"])
    //    .setKey(ProcessInfo.processInfo.environment["APPWRITE_API_KEY"]);

    // You can log messages to the console
    context.log("Hello, Logs!")

    // If something goes wrong, log an error
    context.error("Hello, Errors!")

    // The `context.req` object contains the request data
    if context.req.method == "GET" {
        // Send a response with the res object helpers
        // `res.send()` dispatches a string back to the client
        return context.res.send("Hello, World!")
    }

    // `context.res.json()` is a handy helper for sending JSON
    return try context.res.json([
        "motto": "Build like a team of hundreds_",
        "learn": "https://appwrite.io/docs",
        "connect": "https://appwrite.io/discord",
        "getInspired": "https://builtwith.appwrite.io",
    ])
}
```
```csharp
namespace DotNetRuntime;

using Appwrite;
using Appwrite.Services;
using Appwrite.Models;

public class Handler {

    // This is your Appwrite function
    // It"s executed each time we get a request
    public async Task Main(RuntimeContext Context) 
    {
        // Why not try the Appwrite SDK?
        //
        // var client = new Client()
        //     .SetEndpoint("https://cloud.appwrite.io/v1")  
        //     .SetProject(Environment.GetEnvironmentVariable("APPWRITE_FUNCTION_PROJECT_ID"))        
        //     .SetKey(Environment.GetEnvironmentVariable("APPWRITE_API_KEY"))

        // You can log messages to the console
        Context.Log("Hello, Logs!");

        // If something goes wrong, log an error
        Context.Error("Hello, Errors!");

        // The `Context.Req` object contains the request data
        if (Context.Req.Method == "GET") {
            // Send a response with the res object helpers
            // `Context.Res.Send()` dispatches a string back to the client
            return Context.Res.Send("Hello, World!");
        }

        // `Context.Res.Json()` is a handy helper for sending JSON
        return Context.Res.Json(new Dictionary()
        {
            { "motto", "Build like a team of hundreds_" },
            { "learn", "https://appwrite.io/docs" },
            { "connect", "https://appwrite.io/discord" },
            { "getInspired", "https://builtwith.appwrite.io" },
        });
    }
}
```
{% /multicode %}

If you prefer to learn through more examples like this, explore the [examples page](/docs/products/functions/examples).

# Context object {% #context-object %}
Context is an object passed into every function to handle communication to both the end users, and logging to the Appwrite Console. 
All input, output, and logging **must be handled through the context object** passed in.

You'll find these properties in the context object.

| Property | Description                                                                                                              |
|----------|--------------------------------------------------------------------------------------------------------------------------|
| req      | Contains request information like method, body, and headers. See full examples [in the request section](#request).                                     |
| res      | Contains methods to build a response and return information. See full examples [in the response section](#response).                                     |
| log()    | Method to log information to the Appwrite Console, end users will not be able to see these logs. See full examples [in the logging section](#logging). |
| error()  | Methoc to log errors to the Appwrite Console, end users will not be able to see these errors. See full examples [in the logging section](#logging).    |

### Destructuring assignment {% #destructuring %}
Some languages, namely JavaScript, support destructuring. 
You'll see us use destructuring in examples, which has the following syntax. 

[Learn more about destructuring assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).
{% multicode %}
```js
// before destructuring
export default async function (context) {
    context.log("This is a log!");
    return context.res.send("This is a response!");
}

// after destructuring
export default async function ({ req, res, log, error }) {
    log("This is a log!");
    return res.send("This is a response!");
}
```
```deno
// before destructuring
export default async function (context: any) {
    context.log("This is a log!");
    return context.res.send("This is a response!");
}
   
// after destructuring
export default async function ({ req, res, log, error }: any) {
    log("This is a log!");
    return res.send("This is a response!");
}
```
{% /multicode %}

## Request {% #request %}

If you pass data into an Appwrite Function, it'll be found in the request object. 
This includes all invocation inputs from Appwrite SDKs, HTTP calls, Appwrite events, or browsers visiting the configured domain. 
Explore the request object with the following function, which logs all request params to the Appwrite Console.

{% multicode %}
```js
export default async ({ req, res, log }) => {
    log(req.bodyRaw);                     // Raw request body, contains request data
    log(JSON.stringify(req.body));        // Object from parsed JSON request body, otherwise string
    log(JSON.stringify(req.headers));     // String key-value pairs of all request headers, keys are lowercase
    log(req.scheme);                      // Value of the x-forwarded-proto header, usually http or https
    log(req.method);                      // Request method, such as GET, POST, PUT, DELETE, PATCH, etc.
    log(req.url);                         // Full URL, for example: http://awesome.appwrite.io:8000/v1/hooks?limit=12&offset=50
    log(req.host);                        // Hostname from the host header, such as awesome.appwrite.io
    log(req.port);                        // Port from the host header, for example 8000
    log(req.path);                        // Path part of URL, for example /v1/hooks
    log(req.queryString);                 // Raw query params string. For example "limit=12&offset=50"
    log(JSON.stringify(req.query));       // Parsed query params. For example, req.query.limit

    return res.send("All the request parameters are logged to the Appwrite Console.");
};
```
```php
<?php
return function ($context) {
    $context->log($context->req->bodyRaw);              // Raw request body, contains request data
    $context->log(json_encode($context->req->body));    // Object from parsed JSON request body, otherwise string
    $context->log(json_encode($context->req->headers)); // String key-value pairs of all request headers, keys are lowercase
    $context->log($context->req->scheme);               // Value of the x-forwarded-proto header, usually http or https
    $context->log($context->req->method);               // Request method, such as GET, POST, PUT, DELETE, PATCH, etc.
    $context->log($context->req->url);                  // Full URL, for example: http://awesome.appwrite.io:8000/v1/hooks?limit=12&offset=50
    $context->log($context->req->host);                 // Hostname from the host header, such as awesome.appwrite.io
    $context->log($context->req->port);                 // Port from the host header, for example 8000
    $context->log($context->req->path);                 // Path part of URL, for example /v1/hooks
    $context->log($context->req->queryString);          // Raw query params string. For example "limit=12&offset=50"
    $context->log(json_encode($context->req->query));   // Parsed query params. For example, req.query.limit

    return $context->res->send("All the request parameters are logged to the Appwrite Console.");
}
```
```python
import json

def main(context):
    context.log(context.req.body_raw)            # Raw request body, contains request data
    context.log(json.dumps(context.req.body))    # Object from parsed JSON request body, otherwise string
    context.log(json.dumps(context.req.headers)) # String key-value pairs of all request headers, keys are lowercase
    context.log(context.req.scheme)              # Value of the x-forwarded-proto header, usually http or https
    context.log(context.req.method)              # Request method, such as GET, POST, PUT, DELETE, PATCH, etc.
    context.log(context.req.url)                 # Full URL, for example: http://awesome.appwrite.io:8000/v1/hooks?limit=12&offset=50
    context.log(context.req.host)                # Hostname from the host header, such as awesome.appwrite.io
    context.log(context.req.port)                # Port from the host header, for example 8000
    context.log(context.req.path)                # Path part of URL, for example /v1/hooks
    context.log(context.req.query_string)        # Raw query params string. For example "limit=12&offset=50"
    context.log(json.dumps(context.req.query))   # Parsed query params. For example, req.query.limit

    return context.res.send("All the request parameters are logged to the Appwrite Console.")
```
```ruby
require 'json'
                
def main(context)
    context.log(context.req.bodyRaw)                #  Raw request body, contains request data
    context.log(JSON.generate(context.req.body))    # Object from parsed JSON request body, otherwise string
    context.log(JSON.generate(context.req.headers)) # String key-value pairs of all request headers, keys are lowercase
    context.log(context.req.scheme)                 # Value of the x-forwarded-proto header, usually http or https
    context.log(context.req.method)                 # Request method, such as GET, POST, PUT, DELETE, PATCH, etc.
    context.log(context.req.url)                    # Full URL, for example: http://awesome.appwrite.io:8000/v1/hooks?limit=12&offset=50
    context.log(context.req.host)                   # Hostname from the host header, such as awesome.appwrite.io
    context.log(context.req.port)                   # Port from the host header, for example 8000
    context.log(context.req.path)                   # Path part of URL, for example /v1/hooks
    context.log(context.req.queryString)            # Raw query params string. For example "limit=12&offset=50"
    context.log(JSON.generate(context.req.query))   # Parsed query params. For example, req.query.limit

    return context.res.send("All the request parameters are logged to the Appwrite Console.")
end
```
```deno
export default async ({ req, res, log }: any) => {
    log(req.bodyRaw);                 // Raw request body, contains request data
    log(JSON.stringify(req.body));    // Object from parsed JSON request body, otherwise string
    log(JSON.stringify(req.headers)); // String key-value pairs of all request headers, keys are lowercase
    log(req.scheme);                  // Value of the x-forwarded-proto header, usually http or https
    log(req.method);                  // Request method, such as GET, POST, PUT, DELETE, PATCH, etc.
    log(req.url);                     // Full URL, for example: http://awesome.appwrite.io:8000/v1/hooks?limit=12&offset=50
    log(req.host);                    // Hostname from the host header, such as awesome.appwrite.io
    log(req.port);                    // Port from the host header, for example 8000
    log(req.path);                    // Path part of URL, for example /v1/hooks
    log(req.queryString);             // Raw query params string. For example "limit=12&offset=50"
    log(JSON.stringify(req.query));   // Parsed query params. For example, req.query.limit

    return res.send("All the request parameters are logged to the Appwrite Console.");
```
```dart
import 'dart:async';
import 'dart:convert';

Future<dynamic> main(final context) async {
    context.log(context.req.bodyRaw);              // Raw request body, contains request data
    context.log(json.encode(context.req.body));    // Object from parsed JSON request body, otherwise string
    context.log(json.encode(context.req.headers)); // String key-value pairs of all request headers, keys are lowercase
    context.log(context.req.scheme);               // Value of the x-forwarded-proto header, usually http or https
    context.log(context.req.method);               // Request method, such as GET, POST, PUT, DELETE, PATCH, etc.
    context.log(context.req.url);                  // Full URL, for example: http://awesome.appwrite.io:8000/v1/hooks?limit=12&offset=50
    context.log(context.req.host);                 // Hostname from the host header, such as awesome.appwrite.io
    context.log(context.req.port);                 // Port from the host header, for example 8000
    context.log(context.req.path);                 // Path part of URL, for example /v1/hooks
    context.log(context.req.queryString);          // Raw query params string. For example "limit=12&offset=50"
    context.log(json.encode(context.req.query));   // Parsed query params. For example, req.query.limit

    return context.res.send("All the request parameters are logged to the Appwrite Console.");
}
```
```swift
import Foundation
import Foundation

func main(context: RuntimeContext) async throws -> RuntimeOutput {
    context.log(context.req.bodyRaw)                                                     // Raw request body, contains request data
    context.log(NSJSONSerialization.jsonObject(with: context.req.body, options: [])!)    // Object from parsed JSON request body, otherwise string
    context.log(NSJSONSerialization.jsonObject(with: context.req.headers, options: [])!) // String key-value pairs of all request headers, keys are lowercase
    context.log(context.req.scheme)                                                      // Value of the x-forwarded-proto header, usually http or https
    context.log(context.req.method)                                                      // Request method, such as GET, POST, PUT, DELETE, PATCH, etc.
    context.log(context.req.url)                                                         // Full URL, for example: http://awesome.appwrite.io:8000/v1/hooks?limit=12&offset=50 
    context.log(context.req.host)                                                        // Hostname from the host header, such as awesome.appwrite.io
    context.log(context.req.port)                                                        // Port from the host header, for example 8000
    context.log(context.req.path)                                                        // Path part of URL, for example /v1/hooks
    context.log(context.req.queryString)                                                 // Raw query params string. For example "limit=12&offset=50"
    context.log(NSJSONSerialization.jsonObject(with: context.req.query, options: [])!)   // Parsed query params. For example, req.query.limit

    return context.res.send("All the request parameters are logged to the Appwrite Console.")
}
```
```csharp
namespace DotNetRuntime;

using System.Text.Json;

public class Handler {
    public async Task<RuntimeOutput> Main(RuntimeContext Context) 
    {
        Context.Log(Context.Req.BodyRaw);                                                     // Raw request body, contains request data
        Context.Log(JsonSerializer.Serialize<object>(Context.Req.Body));                 // Object from parsed JSON request body, otherwise string
        Context.Log(JsonSerializer.Serialize<object>(Context.Req.Headers));              // String key-value pairs of all request headers, keys are lowercase
        Context.Log(Context.Req.Scheme);                                                      // Value of the x-forwarded-proto header, usually http or https
        Context.Log(Context.Req.Method);                                                      // Request method, such as GET, POST, PUT, DELETE, PATCH, etc.
        Context.Log(Context.Req.Url);                                                         // Full URL, for example: http://awesome.appwrite.io:8000/v1/hooks?limit=12&offset=50
        Context.Log(Context.Req.Host);                                                        // Hostname from the host header, such as awesome.appwrite.io
        Context.Log(Context.Req.Port);                                                        // Port from the host header, for example 8000
        Context.Log(Context.Req.Path);                                                        // Path part of URL, for example /v1/hooks
        Context.Log(Context.Req.QueryString);                                                 // Raw query params string. For example "limit=12&offset=50"
        Context.Log(JsonSerializer.Serialize<object>(Context.Req.Query));                // Parsed query params. For example, req.query.limit

        return Context.Res.Send("All the request parameters are logged to the Appwrite Console.");
    }
}
```
```kotlin
package io.openruntimes.kotlin.src

import io.openruntimes.kotlin.RuntimeContext
import io.openruntimes.kotlin.RuntimeOutput
import com.google.gson.Gson

class Main {
    fun main(context: RuntimeContext): RuntimeOutput {
        val gson = Gson()

        context.log(context.req.bodyRaw)                // Raw request body, contains request data
        context.log(gson.toString(context.req.body))    // Object from parsed JSON request body, otherwise string
        context.log(gson.toString(context.req.headers)) // String key-value pairs of all request headers, keys are lowercase
        context.log(context.req.scheme)                 // Value of the x-forwarded-proto header, usually http or https
        context.log(context.req.method)                 // Request method, such as GET, POST, PUT, DELETE, PATCH, etc.
        context.log(context.req.url)                    // Full URL, for example: http://awesome.appwrite.io:8000/v1/hooks?limit=12&offset=50
        context.log(context.req.host)                   // Hostname from the host header, such as awesome.appwrite.io
        context.log(context.req.port)                   // Port from the host header, for example 8000
        context.log(context.req.path)                   // Path part of URL, for example /v1/hooks
        context.log(context.req.queryString)            // Raw query params string. For example "limit=12&offset=50"
        context.log(gson.toString(context.req.query))   // Parsed query params. For example, req.query.limit

        return context.res.send("All the request parameters are logged to the Appwrite Console.")
    }
}
```
```java
package io.openruntimes.java;

import com.google.gson.Gson;
import io.openruntimes.java.models.RuntimeContext;
import io.openruntimes.java.models.RuntimeOutput;

public class Main {
    public RuntimeOutput main(RuntimeContext context) {
        Gson gson = new Gson();

        context.log(context.getReq().getBodyRaw());                // Raw request body, contains request data
        context.log(gson.toString(context.getReq().getBody()));    // Object from parsed JSON request body, otherwise string
        context.log(gson.toString(context.getReq().getHeaders())); // String key-value pairs of all request headers, keys are lowercase
        context.log(context.getReq().getScheme());                 // Value of the x-forwarded-proto header, usually http or https
        context.log(context.getReq().getMethod());                 // Request method, such as GET, POST, PUT, DELETE, PATCH, etc.
        context.log(context.getReq().getUrl());                    // Full URL, for example: http://awesome.appwrite.io:8000/v1/hooks?limit=12&offset=50
        context.log(context.getReq().getHost());                   // Hostname from the host header, such as awesome.appwrite.io
        context.log(context.getReq().getPort());                   // Port from the host header, for example 8000
        context.log(context.getReq().getPath());                   // Path part of URL, for example /v1/hooks
        context.log(context.getReq().getQueryString());            // Raw query params string. For example "limit=12&offset=50"
        context.log(gson.toString(context.getReq().getQuery()));   // Parsed query params. For example, req.query.limit

        return context.getRes().send("All the request parameters are logged to the Appwrite Console.");
    }
}
```
{% /multicode %}

### Headers {% #headers %}

Appwrite Functions will always receive a set of headers that provide meta data about the function execution. 
These are provided alongside any custom headers sent to the function.

| Variable                  | Description                                                                                                                                          |
|---------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------|
| `x-appwrite-trigger`        |  Describes how the function execution was invoked. Possible values are `http`, `schedule` or `event`.                                                      |
| `x-appwrite-event`          |  If the function execution was triggered by an event, describes the triggering event.                                                                |
| `x-appwrite-user-id`        |  If the function execution was invoked by an authenticated user, display the user ID. This doesn't apply to Appwrite Console users or API keys.      |
| `x-appwrite-user-jwt`       |  JWT token generated from the invoking user's session. Used to authenticate Server SDKs to respect access permissions. [Learn more about JWT tokens](/docs/products/auth/jwt).  |
| `x-appwrite-country-code`   |  Displays the country code of the configured locale.                                                                                                 |
| `x-appwrite-continent-code` |  Displays the continent code of the configured locale.                                                                                               |
| `x-appwrite-continent-eu`   |  Describes if the configured local is within the EU.                                                                                                 |

## Response {% #response %}
If you need to send a response to the invoker of the function, such as a user, client app, or an integration, use the response object. 
The response information **will not be logged** to the Appwrite Console. 
There are several possible ways to send a response, explore them in the following Appwrite Function.

{% multicode %}
```js
export default async ({ req, res, log }) => {

    switch (req.query.type) {
        case 'empty': 
            return res.empty();
        case 'json':
            return res.json({"type": "This is a JSON response"});
        case 'redirect':
            return res.redirect("https://appwrite.io", 301);
        case 'html':
            return res.send(
                "<h1>This is an HTML response</h1>", 200, {
                    "content-type": "text/html"
                });
        default:
            return res.send("This is a text response");
    }
}
```
```php
<?php

return function ($context) {
    switch ($context->req->query['type']) {
        case 'empty':
            return $context->res->empty();
        case 'json':
            return $context->res->json(["type" => "This is a JSON response"]);
        case 'redirect':
            return $context->res->redirect("https://appwrite.io", 301);
        case 'html':
            return $context->res->send("<h1>This is an HTML response</h1>", 200, [
                "content-type" => "text/html"
                ]);
        default:
            return $context->res->send("This is a text response");
    }
};
```
```python
def main(context):
    type = context.req.query['type']

    if type == 'empty':
        return context.res.empty()
    elif type =='json':
        return context.res.json({"type": "This is a JSON response"})
    elif type == 'redirect':
        return context.res.redirect("https://appwrite.io", 301)
    elif type == 'html':
        return context.res.send("<h1>This is an HTML response</h1>", 200, {
            "content-type": "text/html"
        })
    else:
        return context.res.send("This is a text response")
```
```ruby
def main(context)
    case context.req.query['type'] 
        when 'empty'
            return context.res.empty()
        when 'json'
            return context.res.json({"type": "This is a JSON response"})
        when 'redirect'
            return context.res.redirect("https://appwrite.io", 301)
        when 'html'
            return context.res.send("<h1>This is an HTML response</h1>", 200, {
                "content-type": "text/html"
            })
        else
            return context.res.send("This is a text response")
    end
end
```
```deno
export default async ({ req, res, log }) => {

    switch (req.query.type) {
        case 'empty':
            return res.empty();
        case 'json':
            return res.json({type": "This is a JSON response"});
        case 'redirect':
            return res.redirect("https://appwrite.io", 301);
        case 'html':
            return res.send(
                "<h1>This is an HTML response</h1>", 200, {
                    "content-type": "text/html"
                });
        default:
            return res.send("This is a text response");
    }
}
```
```dart
import 'dart:async';

Future<dynamic> main(final context) async {
    switch (context.req.query['type']) {
        case 'empty':
            return context.res.empty();
        case 'json':
            return context.res.json({'type': 'This is a JSON response'});
        case 'redirect':
            return context.res.redirect('https://appwrite.io', 301);
        case 'html':
            return context.res.send('<h1>This is an HTML response</h1>',
                200, {'content-type': 'text/html'});
        default:
            return context.res.send('This is a text response');
  }
}
```
```swift
import Foundation

func main(context: RuntimeContext) async throws -> RuntimeOutput {
    switch context.req.query["type"] {
    case "empty":
        return context.res.empty()
    case "json":
        return context.res.send(["type": "This is a JSON response"])
    case "redirect":
        return context.res.redirect("https://appwrite.io", 301)
    case "html":
        return context.res.send("<h1>This is an HTML response</h1>", 200, [
            "content-type": "text/html"
            ])
    default:
        return context.res.send("This is a text response")
    }
}
```
```csharp
public class Handler {
    public async Task<RuntimeOutput> Main(RuntimeContext Context) 
    {
        switch (Context.Request.Query["type"])
        {
            case "empty":
                return Context.Res.Empty();
            case "json":
                return Context.Res.Send(new Dictionary<string, object>() { { "type", "This is a JSON response" } });
            case "redirect":
                return Context.Res.Redirect("https://appwrite.io", 301);
            case "html":
                return Context.Res.Send("<h1>This is an HTML response</h1>", 200, new Dictionary<string, string>() {
                    { "content-type", "text/html" } 
                });
            default:
                return Context.Res.Send("This is a text response");
        }
    }
}
```
```kotlin
package io.openruntimes.kotlin.src

import io.openruntimes.kotlin.RuntimeContext
import io.openruntimes.kotlin.RuntimeOutput

class Main {
    fun main(context: RuntimeContext): RuntimeOutput {
        when (context.req.query["type"]) {
            "empty" -> return context.res.empty()
            "json" -> return context.res.send(mapOf("type" to "This is a JSON response"))
            "redirect" -> return context.res.redirect("https://appwrite.io", 301)
            "html" -> return context.res.send("<h1>This is an HTML response</h1>", 200, mapOf("content-type" to "text/html"))
            else -> return context.res.send("This is a text response")
        }
    }
}
```
```java
package io.openruntimes.java.src;

import io.openruntimes.java.RuntimeContext;
import io.openruntimes.java.RuntimeOutput;
import java.util.Map;
import java.util.HashMap;

public class Main {
    public RuntimeOutput main(RuntimeContext context) throws Exception {
        switch (context.getReq().getQuery()["type"]) {
            case "text":
                return context.getRes().empty();
            case "json":
                HashMap<String, Object> data = new HashMap<>();
                data.put("type", "This is a JSON response");
                return context.getRes().send(data);
            case "redirect":
                return context.getRes().redirect("https://appwrite.io", 301);
            case "html":
                return context.getRes().send("<h1>This is an HTML response</h1>", 200, Map.of("content-type", "text/html"));
            default:
                return context.getRes().send("This is a text response");
        }
    }
}
```
```cpp
#include "../RuntimeResponse.h"
#include "../RuntimeRequest.h"
#include "../RuntimeOutput.h"
#include "../RuntimeContext.h"

namespace runtime {
  class Handler {
    public:
      static RuntimeOutput main(RuntimeContext &context) {
        std::string type = context.req.query["type"];

        if (type == "empty") {
          return context.res.empty();
        } else if (type == "json") {
          Json::Value data;
          data["type"] = "This is a JSON response";
          return context.res.send(data);
        } else if (type == "redirect") {
          return context.res.redirect("https://appwrite.io", 301);
        } else if (type == "html") {
          Json::Value headers;
          headers["content-type"] = "text/html";
          return context.res.send("<h1>This is an HTML response</h1>", 200, headers);
        } else {
          return context.res.send("This is a text response");
        }
      }
  };
}
```
{% /multicode %}

To get the different response types, set one of the following query parameters in the [generated domain](/docs/products/functions/deployment#domains) of your function.

| Type     | Query Param     | Example                                                     |
|----------|-----------------|-------------------------------------------------------------|
| `text`     | `/?type=text`     | `https://64d4d22db370ae41a32e.appwrite.global/?type=text`     |
| `json`     | `/?type=json`     | `https://64d4d22db370ae41a32e.appwrite.global/?type=json`     |
| `redirect` | `/?type=redirect` | `https://64d4d22db370ae41a32e.appwrite.global/?type=redirect` |
| `html`     | `/?type=html`     | `https://64d4d22db370ae41a32e.appwrite.global/?type=html`     |
| `empty`    | `/`               | `https://64d4d22db370ae41a32e.appwrite.global/`               |

## Logging {% #logging %}
To protect user privacy, the request and response objects are not logged to the Appwrite Console by default. 
This means, to see logs or debug function executions you need to use the `log()` and `error()` methods. 
These logs are only visible to developers with access to the Appwrite Console.

Here's an example of using logs and errors.

{% multicode %}
```js
export default async ({ req, res, log, error }) => {
    log("This is a log, use for logging information to console");
    log(`This function was called with ${req.method} method`);
    error("This is an error, use for logging errors to console");

    return res.send("Check the Appwrite Console to see logs and errors!");
};
```
```php
<?php

return function ($context) {
    $context->log("This is a log, use for logging information to console");
    $context->log("This function was called with " . $context->req->method . " method");
    $context->error("This is an error, use for logging errors to console");

    return $context->send("Check the Appwrite Console to see logs and errors!");
};
```
```python
def main(context):
    context.log("This is a log, use for logging information to console")
    context.log(f"This function was called with {context.req.method} method")
    context.error("This is an error, use for logging errors to console")

    return context.res.send("Check the Appwrite Console to see logs and errors!")
```
```ruby
def main(context)
    context.log("This is a log, use for logging information to console")
    context.log("This function was called with #{context.req.method} method")
    context.error("This is an error, use for logging errors to console")

    return context.res.send("Check the Appwrite Console to see logs and errors!")
end
```
```deno
export default async ({ res, log, error }: any) => {
    log("This is a log, use for logging information to console");
    log(`This function was called with ${context.req.method} method`);
    error("This is an error, use for logging errors to console");

    return res.send("Check the Appwrite Console to see logs and errors!");
};
```
```dart
import 'dart:async';

Future<dynamic> main(final context) async {
    context.log("This is a log, use for logging information to console");
    context.log("This function was called with ${context.req.method} method");
    context.error("This is an error, use for logging errors to console");

    return context.res.send("Check the Appwrite Console to see logs and errors!");
}
```
```swift
import Foundation

func main(context: RuntimeContext) async throws -> RuntimeOutput {
    context.log("This is a log, use for logging information to console")
    context.log("This function was called with \(context.req.method) method")
    context.error("This is an error, use for logging errors to console")

    return context.res.send("Check the Appwrite Console to see logs and errors!")
}
```
```csharp
namespace DotNetRuntime;

public class Handler {
    public async Task<RuntimeOutput> Main(RuntimeContext Context) 
    {
        Context.Log("This is a log, use for logging information to console");
        Context.Log($"This function was called with {Context.Req.Method} method");
        Context.Error("This is an error, use for logging errors to console");

        return Context.Res.Send("Check the Appwrite Console to see logs and errors!");
    }
}
```
```kotlin
package io.openruntimes.kotlin.src

import io.openruntimes.kotlin.RuntimeContext
import io.openruntimes.kotlin.RuntimeOutput

class Main {
    fun main(context: RuntimeContext): RuntimeOutput {
        context.log("This is a log, use for logging information to console")
        context.log("This function was called with ${context.req.method} method")
        context.error("This is an error, use for logging errors to console")

        return context.res.send("Check the Appwrite Console to see logs and errors!")
    }
}
```
```java
package io.openruntimes.java.src;

import io.openruntimes.java.RuntimeContext;
import io.openruntimes.java.RuntimeOutput;

public class Main {
    public RuntimeOutput main(RuntimeContext context) throws Exception {
        context.log("This is a log, use for logging information to console");
        context.log("This function was called with " + context.req.method + " method");
        context.error("This is an error, use for logging errors to console");

        return context.getRes().send("Check the Appwrite Console to see logs and errors!");
    }
}
```
```cpp
#include "../RuntimeResponse.h"
#include "../RuntimeRequest.h"
#include "../RuntimeOutput.h"
#include "../RuntimeContext.h"

namespace runtime {
  class Handler {
    public:
      static RuntimeOutput main(RuntimeContext &context) {
        context.log("This is a log, use for logging information to console");
        context.log("This function was called with " + context.req.method + " method");
        context.error("This is an error, use for logging errors to console");

        return context.res.send("Check the Appwrite Console to see logs and errors!");
      }
  };
}
```
{% /multicode %}

You can access these logs through the following steps.

1. In Appwrite Console, navigate to Functions.
2. Click to open a function you wish to inspect.
3. Under the Executions tab, click on an execution.
4. In the Response section, you'll be able to view logs under the Logs and Errors tabs.

# Accessing environment variables {% #environment-variables %} 
If you need to pass constants or secrets to Appwrite Functions, you can use environment variables. 
Environmental variables can be global, or function-specific.

{% info title="Appwrite API keys" %}
If your function is using an Appwrite SDK with an API key, this API key needs to be generated and passed in manually. API keys are not passed by default for security reasons.
{% /info %}

| Variable                          | Description                                    |
|-----------------------------------|------------------------------------------------|
| `APPWRITE_FUNCTION_ID`              |  The ID of the running function.               |
| `APPWRITE_FUNCTION_NAME`            |  The Name of the running function.             |
| `APPWRITE_FUNCTION_DEPLOYMENT`      |  The deployment ID of the running function.    |
| `APPWRITE_FUNCTION_PROJECT_ID`      |  The project ID of the running function.       |
| `APPWRITE_FUNCTION_RUNTIME_NAME`    |  The runtime of the running function.          |
| `APPWRITE_FUNCTION_RUNTIME_VERSION` |  The runtime version of the running function.  |

## Function-level environment variables {% #function-variables %} 
Function-level environment variables will only be accessible in the function they belong to. 
Function-level environment variables will override project-level variables when they have conflicting names.

1. In Appwrite Console, navigate to **Functions**.
2. Click to open a function you wish to add variables to.
3. Under the **Settings** tab, navigate to **Environment variables**.
4. Create an environment variable by clicking **Create variable**, using the **Editor**, or import new variables through a `.env` file.

## Project-level variables {% #project-variables %} 
Project-level variables are accessible to all Appwrite Functions in your project. 
Function-level environment variables will override project-level variables when they have conflicting names.

In the Appwrite Console, navigate to your project's **Settings** page.
Navigate to **Global variables** section.
Create an environment variable by clicking **Create variable**, using the **Editor**, or import new variables through a `.env` file.

You can access the environment variables through the systems library of each language.

{% multicode %}
```js
export default async ({ req, res, log }) => {
    return res.send(process.env.MY_VAR);
}
```
```php
<?php

return function ($context) {
    return $context->res->send(getenv('MY_VAR'));
};
```
```python
def main(context):
    return context.res.send(os.environ['MY_VAR'])
```
```ruby
def main(context)
    return context.res.send(ENV['MY_VAR'])
end
```
```deno
export default async ({ req, res, log }) => {
    return res.send(Deno.env.get('MY_VAR'));
}
```
```dart
import 'dart:io';
import 'dart:async';

Future<dynamic> main(final context) async {
    return context.res.send(Platform.environment['MY_VAR']);
}
```
```swift
import Foundation

func main(context: RuntimeContext) async throws -> RuntimeOutput {
    return context.res.send(ProcessInfo.processInfo.environment["MY_VAR"])
}
```
```csharp
namespace DotNetRuntime;

public class Handler {
    public async Task<RuntimeOutput> Main(RuntimeContext Context) 
    {
        return Context.Res.Send(Environment.GetEnvironmentVariable("MY_VAR"));
    }
}
```
```kotlin
package io.openruntimes.kotlin.src

import io.openruntimes.kotlin.RuntimeContext
import io.openruntimes.kotlin.RuntimeOutput

class Main {
    fun main(context: RuntimeContext): RuntimeOutput {
        return context.res.send(System.getenv("MY_VAR"))
    }
}
```
```java
package io.openruntimes.java.src;

import io.openruntimes.java.RuntimeContext;
import io.openruntimes.java.RuntimeOutput;

public class Main {
    public RuntimeOutput main(RuntimeContext context) throws Exception {
        return context.getRes().send(System.getenv("MY_VAR"));
    }
}
```
```cpp
#include "../RuntimeResponse.h"
#include "../RuntimeRequest.h"
#include "../RuntimeOutput.h"
#include "../RuntimeContext.h"

namespace runtime {
  class Handler {
    public:
      static RuntimeOutput main(RuntimeContext &context) {

      return context.res.send(std::getenv("MY_VAR"));
  };
}
```
{% /multicode %}

# Dependencies {% #dependencies %} 
Your function's dependencies should be managed by the package manager of each language. 
By default, we include the following package managers in each runtime.

{% table %}
* &nbsp; {% width=80 %}
* Language
* Package Manager
* Commands
---
* {% only_dark %}{% icon_image src="/images/platforms/dark/nodejs.svg" alt="Node.js logo" size="m" /%}{% /only_dark %}
{% only_light %}{% icon_image src="/images/platforms/nodejs.svg" alt="Node.js logo" size="m" /%}{% /only_light %}
* Node.js
* NPM
* `npm install`
---
* {% only_dark %}{% icon_image src="/images/platforms/dark/php.svg" alt="PHP logo" size="m" /%}{% /only_dark %}
{% only_light %}{% icon_image src="/images/platforms/php.svg" alt="PHP logo" size="m" /%}{% /only_light %}
* PHP
* Composer
* `composer install`
---
* {% only_dark %}{% icon_image src="/images/platforms/dark/python.svg" alt="Python logo" size="m" /%}{% /only_dark %}
{% only_light %}{% icon_image src="/images/platforms/python.svg" alt="Python logo" size="m" /%}{% /only_light %}
* Python
* pip
* `pip install -r requirements.txt`
---
* {% only_dark %}{% icon_image src="/images/platforms/dark/ruby.svg" alt="Ruby logo" size="m" /%}{% /only_dark %}
{% only_light %}{% icon_image src="/images/platforms/ruby.svg" alt="Ruby logo" size="m" /%}{% /only_light %}
* Ruby
* Bundler
* `bundle install`
---
* {% only_dark %}{% icon_image src="/images/platforms/dark/deno.svg" alt="Deno logo" size="m" /%}{% /only_dark %}
{% only_light %}{% icon_image src="/images/platforms/deno.svg" alt="Deno logo" size="m" /%}{% /only_light %}
* Deno
* deno
* `deno cache <ENTRYPOINT_FILE>`
---
* {% only_dark %}{% icon_image src="/images/platforms/dark/dart.svg" alt="Dart logo" size="m" /%}{% /only_dark %}
{% only_light %}{% icon_image src="/images/platforms/dart.svg" alt="Dart logo" size="m" /%}{% /only_light %}
* Dart
* pub
* `pub get`
---
* {% only_dark %}{% icon_image src="/images/platforms/dark/swift.svg" alt="Swift logo" size="m" /%}{% /only_dark %}
{% only_light %}{% icon_image src="/images/platforms/swift.svg" alt="Swift logo" size="m" /%}{% /only_light %}
* Swift
* Swift Package Manager
* `swift package resolve`
---
* {% only_dark %}{% icon_image src="/images/platforms/dark/dotnet.svg" alt=".NET logo" size="m" /%}{% /only_dark %}
{% only_light %}{% icon_image src="/images/platforms/dotnet.svg" alt=".NET logo" size="m" /%}{% /only_light %}
* .NET
* NuGet
* `dotnet restore`
---
* {% only_dark %}{% icon_image src="/images/platforms/dark/bun.svg" alt="Bun logo" size="m" /%}{% /only_dark %}
{% only_light %}{% icon_image src="/images/platforms/bun.svg" alt="Bun logo" size="m" /%}{% /only_light %}
* Bun
* bun
* `bun install`
---
* {% only_dark %}{% icon_image src="/images/platforms/dark/kotlin.svg" alt="Kotlin logo" size="m" /%}{% /only_dark %}
{% only_light %}{% icon_image src="/images/platforms/kotlin.svg" alt="Kotlin logo" size="m" /%}{% /only_light %}
* Kotlin
* Gradle
* N/A
---
* {% only_dark %}{% icon_image src="/images/platforms/dark/java.svg" alt="Java logo" size="m" /%}{% /only_dark %}
{% only_light %}{% icon_image src="/images/platforms/java.svg" alt="Java logo" size="m" /%}{% /only_light %}
* Java
* Gradle
* N/A
---
* {% only_dark %}{% icon_image src="/images/platforms/dark/c.svg" alt="C++ logo" size="m" /%}{% /only_dark %}
{% only_light %}{% icon_image src="/images/platforms/c.svg" alt="C++ logo" size="m" /%}{% /only_light %}
* C++
* None
* N/A
{% /table %}


To install your dependencies before your function is built, you should add the relevant install command to the top your function's **Build setting** > **Commands**.

# Using Appwrite in a function {% #using-appwrite %} 
Appwrite can be used in your functions by adding the relevant SDK to your function's dependencies. 
Authenticating with Appwrite is done via an API key or a JWT token. 
API keys must be generated and exported as an [environment variable](/docs/advanced/self-hosting/environment-variables).

You can read more about authentication in the [JWT login](/docs/products/auth/jwt) section of the docs.

## Using with API key {% #using-api-key %} 
API keys have defined scopes when you create them. 
They ignore permissions and operate without a sessions. 
Use API keys if the function should act as an admin type role, instead of acting on behalf of a user. 
Pass in your API key as an environment variable. 
Never share API keys with users.

{% multicode %}
```js
import { Client, Databases, ID } from 'node-appwrite';

export default async ({ req, res, log, error }) => {

    const client = new Client()
        .setEndpoint('https://cloud.appwrite.io/v1')
        .setProject(process.env.APPWRITE_FUNCTION_PROJECT_ID)
        .setKey(process.env.APPWRITE_API_KEY);

    const databases = new Databases(client);

    try {
        await databases.createDocument(
            '[DATABASE_ID]',
            '[COLLECTION_ID]',
            ID.unique(),
            {}
        )
    } catch (e) {
        error("Failed to create document: " + e.message)
        return res.send("Failed to create document")
    }

    return res.send("Document created")
}
```
```php
<?php

require(__DIR__ . '/../vendor/autoload.php');

use Appwrite\Client;
use Appwrite\Exception;
use Appwrite\Services\Databases;
use Appwrite\ID;

return function ($context) {
    $client = (new Client())
        ->setEndpoint('https://cloud.appwrite.io/v1')
        ->setProject(getenv('APPWRITE_FUNCTION_PROJECT_ID'))
        ->setKey(getenv('APPWRITE_API_KEY'));
    
    $databases = new Databases($client);

    try {
        $databases->createDocument(
            databaseId: '[DATABASE_ID]',
            collectionId: '[COLLECTION_ID]',
            documentId: ID::unique(),
            data: []
        );
    } catch (Exception $e) {
        $context->error("Failed to create document: " . $e->getMessage());
        return $context->res->send("Failed to create document");
    }

    return $context->res->send("Document created");
};
```
```python
from appwrite.client import Client
from appwrite.services.databases import Databases
from appwrite.id import ID

import os

def main(context):
    client = (
        Client()
            .set_endpoint("https://cloud.appwrite.io/v1")
            .set_project(os.environ["APPWRITE_FUNCTION_PROJECT_ID"])
            .set_key(os.environ["APPWRITE_API_KEY"])
    )

    databases = Databases(client)

    try:
        databases.create_document(
            database_id="[DATABASE_ID]",
            collection_id="[COLLECTION_ID]",
            document_id=ID.unique(),
            data={}
        )
    except Exception as e:
        context.error("Failed to create document: " + e.message)
        return context.response.send("Failed to create document")

    return context.response.send("Document created")
```
```ruby
require "appwrite"

include Appwrite

def main(context)
    client = Client.new
        .set_endpoint('https://cloud.appwrite.io/v1')
        .set_project(ENV['APPWRITE_FUNCTION_PROJECT_ID'])
        .set_key(ENV['APPWRITE_API_KEY'])

    databases = Appwrite::Databases.new(client)

    begin
        databases.create_document(
            databaseId: '[DATABASE_ID]',
            collectionId: '[COLLECTION_ID]',
            documentId: ID.unique(),
            data: {}
        )
    rescue Exception => e
        context.error("Failed to create document: " + e.message)
        return context.response.send("Failed to create document")
    end

    return context.response.send("Document created")
end
```
```deno
import { Client, Databases, ID } from "https://deno.land/x/appwrite/mod.ts";
                
export default function ({req, res, error}: any){
    const client = new Client()
        .setEndpoint("https://cloud.appwrite.io/v1")
        .setProject(Deno.env.get("APPWRITE_FUNCTION_PROJECT_ID") || "")
        .setKey(Deno.env.get("APPWRITE_API_KEY") || "");
    
    const databases = new Databases(client);
    
    try {
        databases.createDocument(
            "[DATABASE_ID]",
            "[COLLECTION_ID]",
            ID.unique(),
            {}
        );
    } catch (e) {
        error("Failed to create document: " + e.message);
        return res.send("Failed to create document");
    }
    
    return res.send("Document created");
}
```
```dart
import 'dart:io';
import 'dart:async';
import 'package:dart_appwrite/dart_appwrite.dart';

Future<dynamic> main(final context) async {
    final client = Client()
        .setEndpoint('https://cloud.appwrite.io/v1')
        .setProject(Platform.environment['APPWRITE_FUNCTION_PROJECT_ID'])
        .setKey(Platform.environment['APPWRITE_API_KEY']);
    
    final databases = Databases(client);
    
    try {
        await databases.createDocument(
            databaseId: '[DATABASE_ID]',
            collectionId: '[COLLECTION_ID]',
            documentId: ID.unique(),
            data: {}
        );
    } catch (e) {
        context.error("Failed to create document: " + e.message);
        return context.res.send("Failed to create document");
    }

    return context.res.send("Document created");
}
```
```swift
import Appwrite
import AppwriteModels
import Foundation

func main(context: RuntimeContext) async throws -> RuntimeOutput {
    let client = Client()
       .setEndpoint("https://cloud.appwrite.io/v1")
       .setProject(ProcessInfo.processInfo.environment["APPWRITE_FUNCTION_PROJECT_ID"])
       .setKey(ProcessInfo.processInfo.environment["APPWRITE_API_KEY"]);

    let databases = Databases(client: client)

    do {
        try await databases.createDocument(
            databaseId: "[DATABASE_ID]", 
            collectionId: "[COLLECTION_ID]",
            documentId: ID.unique(),
            data: [:]
        )
    } catch {
        context.error("Failed to create document: \(error.localizedDescription)")
        return context.res.send("Failed to create document")
    }

    return context.res.send("Document created")
}
```
```csharp
using Appwrite;
using Appwrite.Services;
using Appwrite.Models;                        
                        
namespace DotNetRuntime
{
    public class Handler 
    {
        public async Task Main(RuntimeContext Context) 
        {
            var client = new Client()
               .SetEndpoint("https://cloud.appwrite.io/v1")
               .SetProject(Environment.GetEnvironmentVariable("APPWRITE_FUNCTION_PROJECT_ID"))
               .SetKey(Environment.GetEnvironmentVariable("APPWRITE_API_KEY"))
    
            var databases = new Databases(client);
    
            try {
                await databases.CreateDocument(
                    databaseId: "[DATABASE_ID]",
                    collectionId: "[COLLECTION_ID]",
                    documentId: ID.Unique(),
                    data: new Dictionary<string, object>());
            } catch (Exception e) {
                Context.Error("Failed to create document: " + e.Message);
                return Context.Response.Send("Failed to create document");
            }
    
            return Context.Response.Send("Document created");
        }
    }
}
```
```kotlin
package io.openruntimes.kotlin.src

import io.openruntimes.kotlin.RuntimeContext
import io.openruntimes.kotlin.RuntimeOutput
import io.appwrite.Client
import io.appwrite.services.Databases
import io.appwrite.ID
import java.util.HashMap

class Main {
    fun main(context: RuntimeContext): RuntimeOutput {
        val client = Client()
           .setEndpoint("https://cloud.appwrite.io/v1")
           .setProject(System.getenv("APPWRITE_FUNCTION_PROJECT_ID"))
           .setKey(System.getenv("APPWRITE_API_KEY"))

        val databases = Databases(client)

        try {
            databases.createDocument(
                databaseId = "[DATABASE_ID]",
                collectionId = "[COLLECTION_ID]",
                documentId = ID.unique()
                data = mapOf()
            )
        } catch (e: Exception) {
            context.error("Failed to create document: " + e.message)
            return context.res.send("Failed to create document")
        }

        return context.res.send("Document created")
    }
}
```
```java
package io.openruntimes.java.src;

import io.openruntimes.java.RuntimeContext;
import io.openruntimes.java.RuntimeOutput;
import java.util.HashMap;
import io.appwrite.Client;

public class Main {
    public RuntimeOutput main(RuntimeContext context) throws Exception {
        Client client = new Client()
            .setEndpoint("https://cloud.appwrite.io/v1")
            .setProject(System.getenv("APPWRITE_FUNCTION_PROJECT_ID"))
            .setKey(System.getenv("APPWRITE_API_KEY"));

        Databases databases = new Databases(client);

        try {
            databases.createDocument(
                "[DATABASE_ID]",
                "[COLLECTION_ID]",
                ID.unique(),
                new HashMap<>()
            );
        } catch (Exception e) {
            context.error("Failed to create document: " + e.getMessage());
            return context.res.send("Failed to create document");
        }

        return context.res.send("Document created");
    }
}
```
{% /multicode %}

## Using with JWT {% #using-jwt %} 
JWTs allow you to act on behalf of an user in your Appwrite Function. 
When using JWTs, you will be able to access and change **only** the resources with the same permissions as the user account that signed the JWT. 
This preserves the permissions you configured on each resource.

If the Appwrite Function is invoked by an authenticated user, `the x-appwrite-user-jwt` header is automatically passed in.

{% multicode %}

```js
import { Client, Databases, ID } from 'node-appwrite';

export default async ({ req, res, log }) => {
    const client = new Client()
        .setEndpoint('https://cloud.appwrite.io/v1')
        .setProject(process.env.APPWRITE_FUNCTION_PROJECT_ID)

    if (req.headers['x-appwrite-user-jwt']) {
        client.setJWT(req.headers['x-appwrite-user-jwt'])
    } else {
        return res.send("Please sign in, JWT not found")
    }

    const databases = new Databases(client);

    try {
        await databases.createDocument(
            '[DATABASE_ID]',
            '[COLLECTION_ID]',
            ID.unique(),
            {}
        )
    } catch (e) {
        log("Failed to create document: " + e.message)
        return res.send("Failed to create document")
    }

    return res.send("Document created")
}
```
```php
<?php

require(__DIR__ . '/../vendor/autoload.php');

use Appwrite\Client;
use Appwrite\Exception;
use Appwrite\Services\Databases;
use Appwrite\ID;

return function ($context) {
    $client = new (Client())
        ->setEndpoint('https://cloud.appwrite.io/v1')
        ->setProject(getenv('APPWRITE_FUNCTION_PROJECT_ID'))
    
    if (isset($context->req->headers['x-appwrite-user-jwt'])) {
        $client->setJWT($context->req->headers['x-appwrite-user-jwt']);
    } else {
        return $context->res->send("Please sign in, JWT not found");
    }
    
    $databases = new Databases($client);

    try {
        $databases->createDocument(
            databaseId: '[DATABASE_ID]',
            collectionId: '[COLLECTION_ID]',
            documentId: ID::unique(),
            data: []
        );
    } catch (Exception $e) {
        $context->error("Failed to create document: " . $e->getMessage());
        return $context->res->send("Failed to create document");
    }

    return $context->res->send("Document created");
};
```
```python
from appwrite.client import Client
from appwrite.services.databases import Databases
from appwrite.id import ID

import os

def main(context):
    client = (
        Client()
            .set_endpoint("https://cloud.appwrite.io/v1")
            .set_project(os.environ["APPWRITE_FUNCTION_PROJECT_ID"])
    )

    if "x-appwrite-user-jwt" in context.req.headers:
        client.set_jwt(context.req.headers["x-appwrite-user-jwt"])
    else:
        return context.res.send("Please sign in, JWT not found")

    databases = Databases(client)

    try:
        databases.create_document(
            database_id="[DATABASE_ID]",
            collection_id="[COLLECTION_ID]",
            document_id=ID.unique(),
            data={}
        )
    except Exception as e:
        context.error("Failed to create document: " + e.message)
        return context.response.send("Failed to create document")

    return context.response.send("Document created")
```
```ruby
require "appwrite"

include Appwrite

def main(context)
    client = Client.new
        .set_endpoint('https://cloud.appwrite.io/v1')
        .set_project(ENV['APPWRITE_FUNCTION_PROJECT_ID'])

    if context.request.headers['x-appwrite-user-jwt']
        client.set_jwt(context.request.headers['x-appwrite-user-jwt'])
    else
        return context.response.send("Please sign in, JWT not found")
    end

    databases = Appwrite::Databases.new(client)

    begin
        databases.create_document('[DATABASE_ID]', '[COLLECTION_ID]', Appwrite::ID.unique(), {})
    rescue Appwrite::Exception => e
        context.error("Failed to create document: " + e.message)
        return context.response.send("Failed to create document")
    end

    return context.response.send("Document created")
end
```
```deno
import { Client, Databases, ID } from "https://deno.land/x/appwrite/mod.ts";
                
export default function ({req, res, error}: any){
    const client = new Client()
        .setEndpoint("https://cloud.appwrite.io/v1")
        .setProject(Deno.env.get("APPWRITE_FUNCTION_PROJECT_ID") || "")
    
    if (req.headers["x-appwrite-user-jwt"]) {
        client.setJWT(req.headers["x-appwrite-user-jwt"]);
    } else {
        return res.send("Please sign in, JWT not found");
    }
    
    const databases = new Databases(client);
    
    try {
        databases.createDocument(
            "[DATABASE_ID]",
            "[COLLECTION_ID]",
            ID.unique(),
            {}
        );
    } catch (e) {
        error("Failed to create document: " + e.message)
        return res.send("Failed to create document");
    }
    
    return res.send("Document created");
}
```
```dart
import 'dart:io';
import 'dart:async';
import 'package:dart_appwrite/dart_appwrite.dart';

Future<dynamic> main(final context) async {
    final client = Client()
        .setEndpoint('https://cloud.appwrite.io/v1')
        .setProject(Platform.environment['APPWRITE_FUNCTION_PROJECT_ID'])
    
    if (context.req.headers['x-appwrite-user-jwt'] != null) {
        client.setJWT(context.req.headers['x-appwrite-user-jwt']);
    } else {
        return context.res.send("Please sign in, JWT not found");
    }
    
    final databases = Databases(client);
    
    try {
        await databases.createDocument(
            databaseId: '[DATABASE_ID]',
            collectionId: '[COLLECTION_ID]',
            documentId: ID.unique(),
            data: {}
        );
    } catch (e) {
        context.error("Failed to create document: " + e.message);
        return context.res.send("Failed to create document");
    }

    return context.res.send("Document created");
}
```
```swift
import Appwrite
import AppwriteModels
import Foundation

func main(context: RuntimeContext) async throws -> RuntimeOutput {
    let client = Client()
       .setEndpoint("https://cloud.appwrite.io/v1")
       .setProject(ProcessInfo.processInfo.environment["APPWRITE_FUNCTION_PROJECT_ID"])
    
    if let jwt = context.req.headers["x-appwrite-user-jwt"] {
        client.setJWT(jwt)
    } else {
        return context.res.send("Please sign in, JWT not found")
    }

    let databases = Databases(client: client)

    do {
        try await databases.createDocument(
            databaseId: "[DATABASE_ID]",
            collectionId: "[COLLECTION_ID]",
            documentId: ID.unique()
            data: [:]
        )
    } catch {
        context.error("Failed to create document: \(error.localizedDescription)")
        return context.res.send("Failed to create document")
    }

    return context.res.send("Document created")
}
```
```csharp
using Appwrite;
using Appwrite.Services;
using Appwrite.Models;

namespace DotNetRuntime
{
    public class Handler
    {
        public async Task Main(RuntimeContext Context)
        {
            var client = new Client()
               .SetEndpoint("https://cloud.appwrite.io/v1")
               .SetProject(Environment.GetEnvironmentVariable("APPWRITE_FUNCTION_PROJECT_ID"))

            if (Context.Req.Headers.ContainsKey("x-appwrite-user-jwt")) {
                client.SetJWT(Context.Req.Headers["x-appwrite-user-jwt"]);
            } else {
                return Context.Res.Send("Please sign in, JWT not found");
            }

            var databases = new Databases(client);

            try {
                await databases.CreateDocument(
                    databaseId: "[DATABASE_ID]",
                    collectionId: "[COLLECTION_ID]",
                    documentId: ID.Unique(),
                    data: new Dictionary<string, object>());
            } catch (Exception e) {
                Context.Error("Failed to create document: " + e.Message);
                return Context.Res.Send("Failed to create document");
            }

            return Context.Res.Send("Document created");
        }
    }
}
```
```kotlin
package io.openruntimes.kotlin.src

import io.openruntimes.kotlin.RuntimeContext
import io.openruntimes.kotlin.RuntimeOutput
import io.appwrite.Client
import io.appwrite.services.Databases
import io.appwrite.ID
import java.util.HashMap

class Main {
    fun main(context: RuntimeContext): RuntimeOutput {
        val client = Client()
           .setEndpoint("https://cloud.appwrite.io/v1")
           .setProject(System.getenv("APPWRITE_FUNCTION_PROJECT_ID"))

        if (context.req.headers["x-appwrite-user-jwt"] != null) {
            client.setJWT(context.req.headers["x-appwrite-user-jwt"])
        } else {
            return context.res.send("Please sign in, JWT not found")
        }

        val databases = Databases(client)

        try {
            databases.createDocument(
                databaseId = "[DATABASE_ID]",
                collectionId = "[COLLECTION_ID]",
                documentId = ID.unique(),
                data = mapOf()
            )
        } catch (e: Exception) {
            context.error("Failed to create document: " + e.message)
            return context.res.send("Failed to create document")
        }

        return context.res.send("Document created")
    }
}
```
```java
package io.openruntimes.java.src;

import io.openruntimes.java.RuntimeContext;
import io.openruntimes.java.RuntimeOutput;
import java.util.HashMap;
import io.appwrite.Client;

public class Main {
    public RuntimeOutput main(RuntimeContext context) throws Exception {
        Client client = new Client()
            .setEndpoint("https://cloud.appwrite.io/v1")
            .setProject(System.getenv("APPWRITE_FUNCTION_PROJECT_ID"))
                
        if (context.req.headers.containsKey("x-appwrite-user-jwt")) {
            client.setJWT(context.req.headers.get("x-appwrite-user-jwt"));
        } else {
            return context.res.send("Please sign in, JWT not found");
        }

        Databases databases = new Databases(client);

        try {
            databases.createDocument(
                "[DATABASE_ID]",
                "[COLLECTION_ID]",
                ID.unique(),
                new HashMap<>()
            );
        } catch (Exception e) {
            context.error("Failed to create document: " + e.getMessage());
            return context.res.send("Failed to create document");
        }

        return context.res.send("Document created");

    }
}
```
{% /multicode %}

# Code splitting {% #code-splitting %}

As your functions grow, you may find yourself needing to split your code into multiple files. This helps you keep your codebase maintainable and easy to read. Here's how you can accomplish code splitting.

{% tabs %}
{% tabsitem #nodejs title="Node.js" %}
```js
// src/utils.js
export function add(a, b) {
    return a + b;
}
```
```js
// src/main.js
import { add } from './utils.js';

export default function ({ res }) {
    return res.send(add(1, 2));
}
```
{% /tabsitem %}

{% tabsitem #php title="PHP" %}
```php
<?php
// src/utils.php
function add($a, $b) {
    return $a + $b;
}
```
```php
<?php
// src/main.php
require_once(__DIR__ . '/utils.php');

return function ($context) {
    return $context->res->send(add(1, 2));
};
```
{% /tabsitem %}

{% tabsitem #python title="Python" %}
```python
# src/utils.py
def add(a, b):
    return a + b
```
```python
# src/main.py
from .utils import add

def main(context):
    return context.res.send(add(1, 2))
```
{% /tabsitem %}

{% tabsitem #ruby title="Ruby" %}
```ruby
# lib/utils.rb
def add(a, b)
    return a + b
end
```
```ruby
# lib/main.rb
require_relative 'utils'

def main(context)
    return context.res.send(add(1, 2))
end
```
{% /tabsitem %}

{% tabsitem #deno title="Deno" %}
```deno
// src/utils.ts
export function add(a: number, b: number): number {
    return a + b;
}
```
```deno
// src/main.ts
import { add } from './utils.ts';

export default function ({res}: {res: any}) {
    return res.send(add(1, 2));
}
```
{% /tabsitem %}

{% tabsitem #dart title="Dart" %}
```dart
// lib/utils.dart
int add(int a, int b) {
    return a + b;
}
```
```dart
// lib/main.dart
import 'dart:async';

import 'package:package_name/utils.dart';

Future<dynamic> main(final context) async {
    return context.res.send(add(1, 2));
}
```
{% /tabsitem %}

{% tabsitem #swift title="Swift" %}
```swift
// Sources/utils.swift
func add(_ a: Int, _ b: Int) -> Int {
    return a + b
}
```
```swift
// Sources/index.swift
import Foundation

func main(context: RuntimeContext) async throws -> RuntimeOutput {
    return context.res.send(add(1, 2))
}
```
{% /tabsitem %}

{% tabsitem #dotnet title=".NET" %}
```csharp
// src/Utils.cs
namespace DotNetRuntime
{
    public static class Utils
    {
        public static int Add(int a, int b)
        {
            return a + b;
        }
    }
}
```
```csharp
// src/Index.cs
namespace DotNetRuntime
{
    public class Handler {
        public async Task<RuntimeOutput> Main(RuntimeContext Context)
        {
            return Context.Res.Send(Utils.Add(1, 2));
        }
    }
}
```
{% /tabsitem %}

{% tabsitem #kotlin title="Kotlin" %}
```kotlin
// src/Utils.kt
package io.openruntimes.kotlin.src

object Utils {
    fun add(a: Int, b: Int): Int {
        return a + b
    }
}
```
```kotlin
// src/Main.kt
package io.openruntimes.kotlin.src

import io.openruntimes.kotlin.RuntimeContext
import io.openruntimes.kotlin.RuntimeOutput
import io.openruntimes.kotlin.Utils

class Main {
    fun main(context: RuntimeContext): RuntimeOutput {
        return context.res.send(Utils.add(1, 2))
    }
}
```
{% /tabsitem %}

{% tabsitem #java title="Java" %}
```java
// src/Utils.java
package io.openruntimes.java.src;

class Utils {
    public static int add(int a, int b) {
        return a + b;
    }
}
```
```java
package io.openruntimes.java.src;

import io.openruntimes.java.RuntimeContext;
import io.openruntimes.java.RuntimeOutput;
import io.openruntimes.java.Utils;

public class Main {
    public RuntimeOutput main(RuntimeContext context) throws Exception {
        return context.res.send(Utils.add(1, 2));
    }
}
```
{% /tabsitem %}
{% /tabs %}

# Upgrade {% #upgrade %}

Appwrite Functions received major updates in Appwrite version 1.4. 
Your old function from 1.3 will continue to work, but it can't be updated directly to a 1.4 function.
You need to create a new function following 1.4 syntax. 
After you've created your new function, point your application code to the new function and delete the old function.

Here's a checklist of things you need to know.

1. The parameter passed into functions has changed. `req` and `res` has been replaced by `context`, which contains new logger methods. [Learn about context](/docs/products/functions/development#context-object).
2. To improve privacy and logging reliability, we provide new `context.log()` and `context.error()` functions. You can no longer use native logging methods. [Learn about logging](/docs/products/functions/development#logging).
3. The old way of `req.variables` has been deprecated. You can now access variables passed into each function as environment variables. [Learn about environment variables](/docs/products/functions/development#environment-variables).
4. The `req` object has been updated to use terminology consistent with typical HTTP concepts. You'll now find familiar concepts like headers, body, HTTP methods, and others. [Learn about request](/docs/products/functions/development#request).
5. The response object has been updated. You can now specify headers, as well as use new methods like return redirects or empty responses. [Learn about response](/docs/products/functions/development#response).
6. Now, you must return a response such as return `context.res.send("")`. This prevents confusing errors when functions are terminated prematurely before a response is sent. [Learn about response](/docs/products/functions/development#response).
7. Some variables about how a function was triggered are now found in the context.req object as headers.
