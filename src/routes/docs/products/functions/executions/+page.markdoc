---
layout: article
title: Execution
description: Understand serverless function execution in Appwrite. Explore how triggers, events, and data flow enable dynamic execution of your code.
---

Each time an Appwrite Function runs, an **execution** is created.
Each execution has a unique ID. If [you enable execution logs](/docs/products/functions/functions#execution-logs) in your function,
you can find function executions logged in the **Executions** tab.

# Execution table {% #execution-table %}

In your function's **Executions** tab, you will see a table of your recent executions.
Here's the information shown on this table.

{% table %}
- Column
- Description
---
- EXECUTION ID
- Unique identifier for each execution
---
- STATUS
- The current status of the execution
---
- CREATED
- Timestamp of when the execution was created
---
- TRIGGER
- The [platform event](/docs/advanced/platform/events) that triggered the execution
---
- METHOD
- The HTTP method used to create the execution
---
- PATH
- The URL path the function execution was called with
---
- DURATION
- The time taken for the execution
{% /table %}

## Execution status {% #execution-status %}

Each execution can have one of the follow status.

{% table %}
- Status
- description
---
- `processing`
- The function execution has begun and has not finished.
---
- `completed`
- The function executed successfully.
---
- `failed`
- The function execution was not successful.
{% /table %}

Function executions can be delayed if you want to trigger them later.

# Delayed executions {% #delayed-executions %}

Delayed executions trigger the function only once at a future date and time. To schedule an execution, navigate to **Your function** > **Executions** > **Execute now** > **Schedule** in the Appwrite Console.

{% only_dark %}
![Add a SMTP provider](/images/docs/functions/execution/dark/scheduled-execution-function.png)
{% /only_dark %}
{% only_light %}
![Add a SMTP provider](/images/docs/functions/execution/scheduled-execution-function.png)
{% /only_light %}

You can also schedule your function executions using a [runtime](/docs/products/functions/runtimes#available-runtimes).

{% multicode %}
```server-nodejs
const sdk = require('node-appwrite');

// Init SDK
const client = new sdk.Client();

const functions = new sdk.Functions(client);

client
    .setEndpoint('https://cloud.appwrite.io/v1') // Your API Endpoint
    .setProject('<YOUR_PROJECT_ID>') // Your project ID
;

const promise = functions.createExecution(
    '<FUNCTION_ID>', // functionId
    '<BODY>', // body (optional)
    false, // async (optional)
    '<PATH>', // path (optional)
    ExecutionMethod.GET, // method (optional)
    {}, // headers (optional)
    '2020-10-15T06:38:00.000+00:00' // schedule execution (optional)
    );

promise.then(function (response) {
    console.log(response);
}, function (error) {
    console.log(error);
});
```
```deno
import * as sdk from "https://deno.land/x/appwrite/mod.ts";

// Init SDK
let client = new sdk.Client();

let functions = new sdk.Functions(client);

client
    .setEndpoint('https://cloud.appwrite.io/v1') // Your API Endpoint
    .setProject('<YOUR_PROJECT_ID>') // Your project ID
;

const promise = functions.createExecution(
        '<FUNCTION_ID>',  // functionId
        '<BODY>', // body (optional)
        false, // async (optional)
        '<PATH>', // path (optional)
        ExecutionMethod.GET, // method (optional)
        {}, // headers (optional)
        '2020-10-15T06:38:00.000+00:00' // schedule execution (optional)
    );

promise.then(function (response) {
    console.log(response);
}, function (error) {
    console.log(error);
});
```
```php
<?php

use Appwrite\Client;
use Appwrite\Services\Functions;

$client = new Client();

$client
    ->setEndpoint('https://cloud.appwrite.io/v1') // Your API Endpoint
    ->setProject('<YOUR_PROJECT_ID>') // Your project ID
;

$functions = new Functions($client);

$result = $functions->createExecution( 
    '<FUNCTION_ID>',  // functionId
    '<BODY>', // body (optional)
    false, // async (optional)
    '<PATH>', // path (optional)
    ExecutionMethod.GET, // method (optional)
    {}, // headers (optional)
    '2020-10-15T06:38:00.000+00:00' // schedule execution (optional)
);
```
```python
from appwrite.client import Client
from appwrite.services.functions import Functions

client = Client()

(client
  .set_endpoint('https://cloud.appwrite.io/v1') # Your API Endpoint
  .set_project('<YOUR_PROJECT_ID>') # Your project ID
)

functions = Functions(client)

result = functions.create_execution( 
    function_id = '<FUNCTION_ID>', # functionId
    body = '<BODY>', # body (optional)
    async = False, # async (optional)
    path = '<PATH>', # path (optional)
    method = ExecutionMethod.GET, # method (optional)
    headers = {} # headers (optional)
    scheduleAt = '2020-10-15T06:38:00.000+00:00' # schedule execution (optional)
)
```
```ruby
require 'appwrite'

include Appwrite

client = Client.new
    .set_endpoint('https://cloud.appwrite.io/v1') # Your API Endpoint
    .set_project('<YOUR_PROJECT_ID>') # Your project ID

functions = Functions.new(client)

response = functions.create_execution(
    function_id: '<FUNCTION_ID>', // functionId
    body: '<BODY>', # body (optional)
    async: false, # async (optional)
    path: '<PATH>', # path (optional)
    method: ExecutionMethod::GET, # method (optional)
    headers: {} # headers (optional)
    scheduledAt: '2020-10-15T06:38:00.000+00:00' # schedule execution (optional)
)

puts response.inspect
```
```csharp
using Appwrite;
using Appwrite.Services;
using Appwrite.Models;

var client = new Client()
    .SetEndPoint("https://cloud.appwrite.io/v1") // Your API Endpoint
    .SetProject("<YOUR_PROJECT_ID>"); // Your project ID

var functions = new Functions(client);

Execution result = await functions.CreateExecution(
    functionId: "<FUNCTION_ID>", // functionId
    body: "<BODY>", // body (optional)
    async: false, // async (optional)
    path: "<PATH>", // path (optional)
    method: ExecutionMethod.GET, // method (optional)
    headers: [object] // headers (optional)
    scheduledAt: "2020-10-15T06:38:00.000+00:00"; // schedule execution (optional)
```
```dart
import 'package:dart_appwrite/dart_appwrite.dart';

void main() { // Init SDK
  Client client = Client();
  Functions functions = Functions(client);

  client
    .setEndpoint('https://cloud.appwrite.io/v1') // Your API Endpoint
    .setProject('<YOUR_PROJECT_ID>') // Your project ID
  ;

  Future result = functions.createExecution(
    functionId: '<FUNCTION_ID>', // functionId
    body: '<BODY>', // (optional)
    xasync: false, // (optional)
    path: '<PATH>', // (optional)
    method: ExecutionMethod.GET, // (optional)
    headers: {}, // (optional)
    scheduledAt: '2020-10-15T06:38:00.000+00:00' // schedule execution (optional)
  );

  result
    .then((response) {
      print(response);
    }).catchError((error) {
      print(error.response);
  });
}
```
```kotlin
import io.appwrite.Client;
import io.appwrite.coroutines.CoroutineCallback;
import io.appwrite.services.Functions;

Client client = new Client()
    .setEndpoint("https://cloud.appwrite.io/v1") // Your API Endpoint
    .setProject("<YOUR_PROJECT_ID>"); // Your project ID

Functions functions = new Functions(client);

functions.createExecution(
    "<FUNCTION_ID>", // functionId
    "<BODY>", // body (optional)
    false, // async (optional)
    "<PATH>", // path (optional)
    "GET", // method (optional)
    mapOf( "a" to "b" ), // headers (optional)
    "2020-10-15T06:38:00.000+00:00", // schedule execution (optional)
    new CoroutineCallback<>((result, error) -> {
        if (error != null) {
            error.printStackTrace();
            return;
        }

        System.out.println(result);
    })
);
```
```java
import io.appwrite.Client;
import io.appwrite.coroutines.CoroutineCallback;
import io.appwrite.services.Functions;

Client client = new Client()
    .setEndpoint("https://cloud.appwrite.io/v1") // Your API Endpoint
    .setProject("<YOUR_PROJECT_ID>"); // Your project ID

Functions functions = new Functions(client);

functions.createExecution(
    "<FUNCTION_ID>", // functionId
    "<BODY>", // body (optional)
    false, // async (optional)
    "<PATH>", // path (optional)
    ExecutionMethod.GET, // method (optional)
    mapOf( "a" to "b" ), // headers (optional)
    "2020-10-15T06:38:00.000+00:00" // schedule execution (optional)
    new CoroutineCallback<>((result, error) -> {
        if (error != null) {
            error.printStackTrace();
            return;
        }

        System.out.println(result);
    })
);
```
```swift
import Appwrite

let client = Client()
    .setEndpoint("https://cloud.appwrite.io/v1") // Your API Endpoint
    .setProject("<YOUR_PROJECT_ID>") // Your project ID

let functions = Functions(client)

let execution = try await functions.createExecution(
  functionId: "<FUNCTION_ID>",
  body: "<BODY>", // optional
  async: false, // optional
  path: "<PATH>", // optional
  method: .gET, // optional
  headers: [:] // optional
  scheduledAt: "2020-10-15T06:38:00.000+00:00" // Optional parameter to schedule execution
)
```
{% /multicode %}

# Execution details {% #execution-details %}

When you click on an execution, you will be taken to an execution detail screen.

{% only_dark %}
![Execution details screen](/images/docs/functions/execution/dark/execute-function.png)
{% /only_dark %}

{% only_light %}
![Execution details screen](/images/docs/functions/execution/execute-function.png)
{% /only_light %}

You can find both request and response details.
Request and response body are **not logged** to protect user privacy.
This ensures that developers do not see user data by default and no sensitive data is retained.

If you need to log debug data or audit logs, you can use [function logging features](/docs/products/functions/develop#logging)
to explicitly log the information you need.

# Log retention {% #log-retention %}

Logs are not retained forever in order to be compliant with GDPR and other data privacy standards.
Free plan organizations will retain logs for 24 hours, Pro plan organizations will retain logs for 7 days.

If you need longer log retention, you can log to an Appwrite collection.
Remember to configure proper permissions and implement Appwrite Functions or other scheduled tasks to expire and clean up logs. 