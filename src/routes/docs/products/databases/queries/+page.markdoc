---
layout: article
title: Queries
description: Harness the power of querying with Appwrite tablesDB. Discover various query options, filtering, sorting, and advanced querying techniques.
---

Many list endpoints in Appwrite allow you to filter, sort, and paginate results using queries. Appwrite provides a common set of syntax to build queries.

# Query class {% #query-class %}

Appwrite SDKs provide a `Query` class to help you build queries. The `Query` class has methods for each type of supported query operation.

# Building queries {% #building-queries %}

Queries are passed to an endpoint through the `queries` parameter as an array of query strings, which can be generated using the `Query` class.

Each query method is logically separated via `AND` operations. For `OR` operation, pass multiple values into the query method separated by commas.
For example `Query.equal('title', ['Avatar', 'Lord of the Rings'])` will fetch the movies `Avatar` or `Lord of the Rings`.

{% info title="Default pagination behavior" %}
By default, results are limited to the **first 25 items**.
You can change this through [pagination](/docs/products/databases/pagination).
{% /info %}

{% multicode %}

```client-web
import { Client, Query, TablesDB } from "appwrite";

const client = new Client()
    .setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
    .setProject('<PROJECT_ID>');

const tablesDB = new TablesDB(client);

tablesDB.listRows(
    '<DATABASE_ID>',
    '<TABLE_ID>',
    [
        Query.equal('title', ['Avatar', 'Lord of the Rings']),
        Query.greaterThan('year', 1999)
    ]
);
```
```server-nodejs
const sdk = require('node-appwrite');

const client = new sdk.Client();

const tablesDB = new sdk.TablesDB(client);

client
    .setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
    .setProject('<PROJECT_ID>')
    .setKey('<YOUR_API_KEY>')
;

const promise = tablesDB.listRows(
    '<DATABASE_ID>',
    '<TABLE_ID>',
    [
        sdk.Query.equal('title', ['Avatar', 'Lord of the Rings']),
        sdk.Query.greaterThan('year', 1999)
    ]
);

promise.then(function (response) {
    console.log(response);
}, function (error) {
    console.log(error);
});
```
```client-flutter
import 'package:appwrite/appwrite.dart';

void main() async {
    final client = Client()
        .setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
        .setProject('<PROJECT_ID>');

    final tablesDB = TablesDB(client);

    try {
        final rows = await tablesDB.listRows(
            '<DATABASE_ID>',
            '<TABLE_ID>',
            [
                Query.equal('title', ['Avatar', 'Lord of the Rings']),
                Query.greaterThan('year', 1999)
            ]
        );
    } on AppwriteException catch(e) {
        print(e);
    }
}
```
```client-apple
import Appwrite
import AppwriteModels

func main() async throws {
    let client = Client()
        .setEndpoint("https://<REGION>.cloud.appwrite.io/v1")
        .setProject("<PROJECT_ID>")

    let tablesDB = TablesDB(client)

    do {
        let rows = try await tablesDB.listRows(
            databaseId: "<DATABASE_ID>",
            tableId: "<TABLE_ID>",
            queries: [
                Query.equal("title", value: ["Avatar", "Lord of the Rings"]),
                Query.greaterThan("year", value: 1999)
            ]
        )
    } catch {
        print(error.localizedDescription)
    }
}
```
```client-android-kotlin
import io.appwrite.Client
import io.appwrite.Query
import io.appwrite.services.TablesDB

suspend fun main() {
    val client = Client(applicationContext)
        .setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
        .setProject('<PROJECT_ID>');

    val tablesDB = TablesDB(client)

    try {
        val rows = tablesDB.listRows(
            databaseId = "<DATABASE_ID>",
            tableId = "<TABLE_ID>",
            queries = listOf(
                Query.equal("title", listOf("Avatar", "Lord of the Rings")),
                Query.greaterThan("year", 1999)
            )
        )
    } catch (e: AppwriteException) {
        Log.e("Appwrite", e.message)
    }
}
```
```php
<?php

use Appwrite\Client;
use Appwrite\Query;
use Appwrite\Services\TablesDB;

$client = new Client();

$client
    ->setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
    ->setProject('<PROJECT_ID>')
    ->setKey('<YOUR_API_KEY>')
;

$tablesDB = new TablesDB($client);

$result = $tables->listRows(
    '<DATABASE_ID>',
    '<TABLE_ID>',
    [
        Query::equal('title', ['Avatar', 'Lord of the Rings']),
        Query::greaterThan('year', 1999)
    ]
);
```
```python
from appwrite.client import Client
from appwrite.query import Query
from appwrite.services.tablesDB import TablesDB

client = Client()

(client
  .set_endpoint('https://<REGION>.cloud.appwrite.io/v1')
  .set_project('<PROJECT_ID>')
  .set_key('<YOUR_API_KEY>')
)

tablesDB = TablesDB(client)

result = tablesDB.list_rows(
    '<DATABASE_ID>',
    '<TABLE_ID>',
    [
        Query.equal('title', ['Avatar', 'Lord of the Rings']),
        Query.greater_than('year', 1999)
    ]
)
```
```graphql
query {
    tablesListRows(
        databaseId: "<DATABASE_ID>",
        tableId: "<TABLE_ID>"
        queries: [
            "{\"method\":\"equal\",\"column\":\"title\",\"values\":[\"Avatar\",\"Lord of the Rings\"]}",
            "{\"method\":\"greaterThan\",\"column\":\"year\",\"values\":[1999]}"
        ]
    ) {
        total
        rows {
            _id
            data
        }
    }
}
```
```http
GET /v1/tablesdb/<DATABASE_ID>/tables/<TABLE_ID>/rows?queries[]=%7B%22method%22%3A%22equal%22%2C%22column%22%3A%22title%22%2C%22values%22%3A%5B%22Avatar%22%2C%22Lord%20of%20the%20Rings%22%5D%7D&queries[]=%7B%22method%22%3A%22greaterThan%22%2C%22column%22%3A%22year%22%2C%22values%22%3A%5B1999%5D%7D HTTP/1.1
Content-Type: application/json
X-Appwrite-Project: <PROJECT_ID>
```
{% /multicode %}

# Query operators {% #query-operators %}

## Select {% #select %}

The `select` operator allows you to specify which columns should be returned from a row. This is essential for optimizing response size, controlling which relationship data loads, and only retrieving the data you need.

{% multicode %}
```client-web
Query.select(["name", "title"])
```
```client-flutter
Query.select(["name", "title"])
```
```python
Query.select(["name", "title"])
```
```ruby
Query.select(["name", "title"])
```
```deno
Query.select(["name", "title"])
```
```php
Query::select(["name", "title"])
```
```swift
Query.select(["name", "title"])
```
```http
{"method":"select","values":["name","title"]}
```
{% /multicode %}

### Select relationship data {% #relationship-select %}

With [opt-in relationship loading](/docs/products/databases/relationships#performance-loading), you must explicitly select relationship data. This gives you fine-grained control over performance and payload size.

#### Get rows without relationships
By default, rows return only their own fields:

{% multicode %}
```client-web
const doc = await tablesDB.getRow(
    '<DATABASE_ID>', '<TABLE_ID>', '<ROW_ID>',
    [Query.select(['name', 'age'])]
);
```
```client-flutter
final doc = await tablesDB.getRow(
    databaseId: '<DATABASE_ID>',
    tableId: '<TABLE_ID>',
    rowId: '<ROW_ID>',
    queries: [Query.select(["name", "age"])]
);
```
```python
doc = tablesDB.get_row(
    '<DATABASE_ID>', '<TABLE_ID>', '<ROW_ID>',
    [Query.select(["name", "age"])]
)
```
```ruby
doc = tablesDB.get_row(
    '<DATABASE_ID>', '<TABLE_ID>', '<ROW_ID>',
    [Query.select(["name", "age"])]
)
```
```server-nodejs
const doc = await tablesDB.getRow(
    '<DATABASE_ID>', '<TABLE_ID>', '<ROW_ID>',
    [Query.select(['name', 'age'])]
);
```
```php
$doc = $tablesDB->getRow(
    '<DATABASE_ID>', '<TABLE_ID>', '<ROW_ID>',
    [Query::select(["name", "age"])]
);
```
```swift
let doc = try await tablesDB.getRow(
    databaseId: "<DATABASE_ID>",
    tableId: "<TABLE_ID>",
    rowId: "<ROW_ID>",
    queries: [Query.select(["name", "age"])]
)
```
```http
GET /v1/tablesdb/<DATABASE_ID>/tables/<TABLE_ID>/rows/<ROW_ID>?queries[]=%7B%22method%22%3A%22select%22%2C%22values%22%3A%5B%22name%22%2C%22age%22%5D%7D HTTP/1.1
Content-Type: application/json
X-Appwrite-Project: <PROJECT_ID>
```
{% /multicode %}

#### Load all relationship data
Use the `*` wildcard to load all fields from related rows:

{% multicode %}
```client-web
const doc = await tablesDB.getRow(
    '<DATABASE_ID>', '<TABLE_ID>', '<ROW_ID>',
    [Query.select(['*', 'reviews.*'])]
);
```
```client-flutter
final doc = await tablesDB.getRow(
    databaseId: '<DATABASE_ID>',
    tableId: '<TABLE_ID>',
    rowId: '<ROW_ID>',
    queries: [Query.select(["*", "reviews.*"])]
);
```
```python
doc = tablesDB.get_row(
    '<DATABASE_ID>', '<TABLE_ID>', '<ROW_ID>',
    [Query.select(["*", "reviews.*"])]
)
```
```ruby
doc = tablesDB.get_row(
    '<DATABASE_ID>', '<TABLE_ID>', '<ROW_ID>',
    [Query.select(["*", "reviews.*"])]
)
```
```server-nodejs
const doc = await tablesDB.getRow(
    '<DATABASE_ID>', '<TABLE_ID>', '<ROW_ID>',
    [Query.select(["*", "reviews.*"])]
);
```
```php
$doc = $tablesDB->getRow(
    '<DATABASE_ID>', '<TABLE_ID>', '<ROW_ID>',
    [Query::select(["*", "reviews.*"])]
);
```
```swift
let doc = try await tablesDB.getRow(
    databaseId: "<DATABASE_ID>",
    tableId: "<TABLE_ID>",
    rowId: "<ROW_ID>",
    queries: [Query.select(["*", "reviews.*"])]
)
```
```http
GET /v1/tablesdb/<DATABASE_ID>/tables/<TABLE_ID>/rows/<ROW_ID>?queries[]=%7B%22method%22%3A%22select%22%2C%22values%22%3A%5B%22%2A%22%2C%22reviews.%2A%22%5D%7D HTTP/1.1
Content-Type: application/json
X-Appwrite-Project: <PROJECT_ID>
{"method":"select","values":["*","reviews.*"]}
```
{% /multicode %}

#### Select specific relationship fields
For precise control, select only specific fields from related rows:

{% multicode %}
```client-web
const doc = await tablesDB.getRow(
    '<DATABASE_ID>', '<TABLE_ID>', '<ROW_ID>',
    [Query.select(['name', 'age', 'reviews.author', 'reviews.rating'])]
);
```
```client-flutter
final doc = await tablesDB.getRow(
    databaseId: '<DATABASE_ID>',
    tableId: '<TABLE_ID>',
    rowId: '<ROW_ID>',
    queries: [Query.select(["name", "age", "reviews.author", "reviews.rating"])]
);
```
```python
doc = tablesDB.get_row(
    '<DATABASE_ID>', '<TABLE_ID>', '<ROW_ID>',
    [Query.select(["name", "age", "reviews.author", "reviews.rating"])]
)
```
```ruby
doc = tablesDB.get_row(
    '<DATABASE_ID>', '<TABLE_ID>', '<ROW_ID>',
    [Query.select(["name", "age", "reviews.author", "reviews.rating"])]
)
```
```server-nodejs
const doc = await tablesDB.getRow(
    '<DATABASE_ID>', '<TABLE_ID>', '<ROW_ID>',
    [Query.select(["name", "age", "reviews.author", "reviews.rating"])]
);
// Result: { name: "John", age: 30, reviews: [{ author: "...", rating: 5 }] }
```
```php
$doc = $tablesDB->getRow(
    '<DATABASE_ID>', '<TABLE_ID>', '<ROW_ID>',
    [Query::select(["name", "age", "reviews.author", "reviews.rating"])]
);
```
```swift
let doc = try await tablesDB.getRow(
    databaseId: "<DATABASE_ID>",
    tableId: "<TABLE_ID>",
    rowId: "<ROW_ID>",
    queries: [Query.select(["name", "age", "reviews.author", "reviews.rating"])]
)
```
```http
# Load specific fields from main and related rows
{"method":"select","values":["name","age","reviews.author","reviews.rating"]}
```
{% /multicode %}

#### Load nested relationships
You can also load relationships of relationships:

{% multicode %}
```client-web
Query.select(["*", "reviews.*", "reviews.author.*"])
```
```client-flutter
Query.select(["*", "reviews.*", "reviews.author.*"])
```
```python
Query.select(["*", "reviews.*", "reviews.author.*"])
```
```ruby
Query.select(["*", "reviews.*", "reviews.author.*"])
```
```server-nodejs
Query.select(["*", "reviews.*", "reviews.author.*"])
```
```php
Query::select(["*", "reviews.*", "reviews.author.*"])
```
```swift
Query.select(["*", "reviews.*", "reviews.author.*"])
```
```http
{"method":"select","values":["*","reviews.*","reviews.author.*"]}
```
{% /multicode %}

### Use selection patterns {% #select-patterns %}

| Pattern | Description | Use case |
|---------|-------------|----------|
| `["field1", "field2"]` | Specific columns only | Minimize response size |
| `["*"]` | All row columns | Get complete row data |
| `["*", "relationName.*"]` | Row + all relationship fields | Load row with complete related data |
| `["field1", "relationName.field2"]` | Specific fields from row and relationships | Precise data loading |
| `["*", "relationName.field1", "relationName.field2"]` | All row fields + specific relationship fields | Partial relationship loading |
| `["relationName.*", "relationName.nestedRelation.*"]` | Nested relationship loading | Load relationships of relationships |

### Optimize performance {% #select-performance %}

**Optimize response size** - Only select the fields you actually need. Smaller responses are faster to transfer and parse.

**Control relationship loading** - Related rows are not loaded by default. Use explicit selection to load only the relationships you need.

**Reduce database load** - Selecting fewer fields reduces database processing time, especially for large rows.

{% info title="Related rows" %}
By default, relationship columns contain only row IDs.
To load the actual related row data, you must explicitly include relationship fields in your select query.
Learn more about [relationship performance optimization](/docs/products/databases/relationships#performance-loading).
{% /info %}

## Comparison operators {% #comparison %}

### Equal {% #equal %}

Returns row if column is equal to any value in the provided array.

{% multicode %}
```client-web
Query.equal("title", ["Iron Man"])
```
```client-flutter
Query.equal("title", ["Iron Man"])
```
```python
Query.equal("title", ["Iron Man"])
```
```ruby
Query.equal("title", ["Iron Man"])
```
```deno
Query.equal("title", ["Iron Man"])
```
```php
Query::equal("title", ["Iron Man"])
```
```swift
Query.equal("title", value: ["Iron Man"])
```
```http
{"method":"equal","column":"title","values":["Iron Man"]}
```
{% /multicode %}

### Not equal {% #not-equal %}

Returns row if column is not equal to any value in the provided array.

{% multicode %}
```client-web
Query.notEqual("title", "Iron Man")
```
```client-flutter
Query.notEqual("title", "Iron Man")
```
```python
Query.not_equal("title", "Iron Man")
```
```ruby
Query.not_equal("title", "Iron Man")
```
```deno
Query.notEqual("title", "Iron Man")
```
```php
Query::notEqual("title", "Iron Man")
```
```swift
Query.notEqual("title", value: "Iron Man")
```
```http
{"method":"notEqual","column":"title","values":"Iron Man"}
```
{% /multicode %}

### Less than {% #less-than %}

Returns row if column is less than the provided value.

{% multicode %}
```client-web
Query.lessThan("score", 10)
```
```client-flutter
Query.lessThan("score", 10)
```
```python
Query.less_than("score", 10)
```
```ruby
Query.less_than("score", 10)
```
```deno
Query.lessThan("score", 10)
```
```php
Query::lessThan("score", 10)
```
```swift
Query.lessThan("score", value: 10)
```
```http
{"method":"lessThan","column":"score","values":[10]}
```
{% /multicode %}

### Less than or equal {% #less-than-equal %}

Returns row if column is less than or equal to the provided value.

{% multicode %}
```client-web
Query.lessThanEqual("score", 10)
```
```client-flutter
Query.lessThanEqual("score", 10)
```
```python
Query.less_than_equal("score", 10)
```
```ruby
Query.less_than_equal("score", 10)
```
```deno
Query.lessThanEqual("score", 10)
```
```php
Query::lessThanEqual("score", 10)
```
```swift
Query.lessThanEqual("score", value: 10)
```
```http
{"method":"lessThanEqual","column":"score","values":[10]}
```
{% /multicode %}

### Greater than {% #greater-than %}

Returns row if column is greater than the provided value.

{% multicode %}
```client-web
Query.greaterThan("score", 10)
```
```client-flutter
Query.greaterThan("score", 10)
```
```python
Query.greater_than("score", 10)
```
```ruby
Query.greater_than("score", 10)
```
```deno
Query.greaterThan("score", 10)
```
```php
Query::greaterThan("score", 10)
```
```swift
Query.greaterThan("score", value: 10)
```
```http
{"method":"greaterThan","column":"score","values":[10]}
```
{% /multicode %}

### Greater than or equal {% #greater-than-equal %}

Returns row if column is greater than or equal to the provided value.

{% multicode %}
```client-web
Query.greaterThanEqual("score", 10)
```
```client-flutter
Query.greaterThanEqual("score", 10)
```
```python
Query.greater_than_equal("score", 10)
```
```ruby
Query.greater_than_equal("score", 10)
```
```deno
Query.greaterThanEqual("score", 10)
```
```php
Query::greaterThanEqual("score", 10)
```
```swift
Query.greaterThanEqual("score", value: 10)
```
```http
{"method":"greaterThanEqual","column":"score","values":[10]}
```
{% /multicode %}

### Between {% #between %}

Returns row if column value falls between the two values. The boundary values are inclusive and can be strings or numbers.

{% multicode %}
```client-web
Query.between("price", 5, 10)
```
```client-flutter
Query.between("price", 5, 10)
```
```python
Query.between("price", 5, 10)
```
```ruby
Query.between("price", 5, 10)
```
```deno
Query.between("price", 5, 10)
```
```php
Query::between("price", 5, 10)
```
```swift
Query.between("price", start: 5, end: 10)
```
```http
{"method":"between","column":"price","values":[5,10]}
```
{% /multicode %}

## Null checks {% #null-checks %}

### Is null {% #is-null %}

Returns rows where column value is null.

{% multicode %}
```client-web
Query.isNull("name")
```
```client-flutter
Query.isNull("name")
```
```python
Query.is_null("name")
```
```ruby
Query.is_null("name")
```
```deno
Query.isNull("name")
```
```php
Query::isNull("name")
```
```swift
Query.isNull("name")
```
```http
{"method":"isNull","column":"name"}
```
{% /multicode %}

### Is not null {% #is-not-null %}

Returns rows where column value is **not** null.

{% multicode %}
```client-web
Query.isNotNull("name")
```
```client-flutter
Query.isNotNull("name")
```
```python
Query.is_not_null("name")
```
```ruby
Query.is_not_null("name")
```
```deno
Query.isNotNull("name")
```
```php
Query::isNotNull("name")
```
```swift
Query.isNotNull("name")
```
```http
{"method":"isNotNull","column":"name"}
```
{% /multicode %}

## String operations {% #string-operations %}

### Starts with {% #starts-with %}

Returns rows if a string column starts with a substring.

{% multicode %}
```client-web
Query.startsWith("name", "Once upon a time")
```
```client-flutter
Query.startsWith("name", "Once upon a time")
```
```python
Query.starts_with("name", "Once upon a time")
```
```ruby
Query.starts_with("name", "Once upon a time")
```
```deno
Query.startsWith("name", "Once upon a time")
```
```php
Query::startsWith("name", "Once upon a time")
```
```swift
Query.startsWith("name", value: "Once upon a time")
```
```http
{"method":"startsWith","column":"name","values":["Once upon a time"]}
```
{% /multicode %}

### Ends with {% #ends-with %}

Returns rows if a string column ends with a substring.

{% multicode %}
```client-web
Query.endsWith("name", "happily ever after.")
```
```client-flutter
Query.endsWith("name", "happily ever after.")
```
```python
Query.ends_with("name", "happily ever after.")
```
```ruby
Query.ends_with("name", "happily ever after.")
```
```deno
Query.endsWith("name", "happily ever after.")
```
```php
Query::endsWith("name", "happily ever after.")
```
```swift
Query.endsWith("name", value: "happily ever after.")
```
```http
{"method":"endsWith","column":"name","values":["happily ever after."]}
```
{% /multicode %}

### Contains {% #contains %}

Returns rows if the array column contains the specified elements or if a string column contains the specified substring.

{% multicode %}
```client-web
// For arrays
Query.contains("ingredients", ['apple', 'banana'])

// For strings
Query.contains("name", "Tom")
```
```client-flutter
// For arrays
Query.contains("ingredients", ['apple', 'banana'])

// For strings
Query.contains("name", "Tom")
```
```python
# For arrays
Query.contains("ingredients", ['apple', 'banana'])

# For strings
Query.contains("name", "Tom")
```
```ruby
# For arrays
Query.contains("ingredients", ['apple', 'banana'])

# For strings
Query.contains("name", "Tom")
```
```deno
// For arrays
Query.contains("ingredients", ['apple', 'banana'])

// For strings
Query.contains("name", "Tom")
```
```php
// For arrays
Query::contains("ingredients", ['apple', 'banana'])

// For strings
Query::contains("name", "Tom")
```
```swift
// For arrays
Query.contains("ingredients", value: ['apple', 'banana'])

// For strings
Query.contains("name", value: "Tom")
```
```http
# For arrays
{"method":"contains","column":"ingredients","values":["apple","banana"]}

# For strings
{"method":"contains","column":"name","values":["Tom"]}
```
{% /multicode %}

### Search {% #search %}

Searches string columns for provided keywords. Requires a [full-text index](/docs/products/databases/tables#indexes) on queried columns.

{% multicode %}
```client-web
Query.search("text", "key words")
```
```client-flutter
Query.search("text", "key words")
```
```python
Query.search("text", "key words")
```
```ruby
Query.search("text", "key words")
```
```deno
Query.search("text", "key words")
```
```php
Query::search("text", "key words")
```
```swift
Query.search("text", value: "key words")
```
```http
{"method":"search","column":"text","values":["key words"]}
```
{% /multicode %}

## Logical operators {% #logical-operators %}

### AND {% #and %}

Returns row if it matches all of the nested sub-queries in the array passed in.

{% multicode %}
```client-web
Query.and([
    Query.lessThan("size", 10),
    Query.greaterThan("size", 5)
])
```
```client-flutter
Query.and([
    Query.lessThan("size", 10),
    Query.greaterThan("size", 5)
])
```
```python
Query.and_queries([
    Query.less_than("size", 10),
    Query.greater_than("size", 5)
])
```
```ruby
Query.and([
    Query.less_than("size", 10),
    Query.greater_than("size", 5)
])
```
```deno
Query.and([
    Query.lessThan("size", 10),
    Query.greaterThan("size", 5)
])
```
```php
Query::and([
    Query::lessThan("size", 10),
    Query::greaterThan("size", 5)
])
```
```swift
Query.and([
    Query.lessThan("size", value: 10),
    Query.greaterThan("size", value: 5)
])
```
```http
{"method":"and","values":[{"method":"lessThan","column":"size","values":[10]},{"method":"greaterThan","column":"size","values":[5]}]}
```
{% /multicode %}

### OR {% #or %}

Returns row if it matches any of the nested sub-queries in the array passed in.

{% multicode %}
```client-web
Query.or([
    Query.lessThan("size", 5),
    Query.greaterThan("size", 10)
])
```
```client-flutter
Query.or([
    Query.lessThan("size", 5),
    Query.greaterThan("size", 10)
])
```
```python
Query.or_queries([
    Query.less_than("size", 5),
    Query.greater_than("size", 10)
])
```
```ruby
Query.or([
    Query.less_than("size", 5),
    Query.greater_than("size", 10)
])
```
```deno
Query.or([
    Query.lessThan("size", 5),
    Query.greaterThan("size", 10)
])
```
```php
Query::or([
    Query::lessThan("size", 5),
    Query::greaterThan("size", 10)
])
```
```swift
Query.or([
    Query.lessThan("size", value: 5),
    Query.greaterThan("size", value: 10)
])
```
```http
{"method":"or","values":[{"method":"lessThan","column":"size","values":[5]},{"method":"greaterThan","column":"size","values":[10]}]}
```
{% /multicode %}

## Ordering {% #ordering %}

### Order descending {% #order-desc %}

Orders results in descending order by column. Column must be indexed.

{% multicode %}
```client-web
Query.orderDesc("column")
```
```client-flutter
Query.orderDesc("column")
```
```python
Query.order_desc("column")
```
```ruby
Query.order_desc("column")
```
```server-nodejs
Query.orderDesc("column")
```
```php
Query::orderDesc("column")
```
```swift
Query.orderDesc("column")
```
```http
{"method":"orderDesc","column":"column"}
```
{% /multicode %}

### Order ascending {% #order-asc %}

Orders results in ascending order by column. Column must be indexed.

{% multicode %}
```client-web
Query.orderAsc("column")
```
```client-flutter
Query.orderAsc("column")
```
```python
Query.order_asc("column")
```
```ruby
Query.order_asc("column")
```
```server-nodejs
Query.orderAsc("column")
```
```php
Query::orderAsc("column")
```
```swift
Query.orderAsc("column")
```
```http
{"method":"orderAsc","column":"column"}
```
{% /multicode %}

## Pagination {% #pagination %}

### Limit {% #limit %}

Limits the number of results returned by the query. Used for [pagination](/docs/products/databases/pagination).

{% multicode %}
```client-web
Query.limit(25)
```
```client-flutter
Query.limit(25)
```
```python
Query.limit(25)
```
```ruby
Query.limit(25)
```
```deno
Query.limit(25)
```
```php
Query::limit(25)
```
```swift
Query.limit(25)
```
```http
{"method":"limit","values":[25]}
```
{% /multicode %}

### Offset {% #offset %}

Offset the results returned by skipping some of the results. Used for [pagination](/docs/products/databases/pagination).

{% multicode %}
```client-web
Query.offset(0)
```
```client-flutter
Query.offset(0)
```
```python
Query.offset(0)
```
```ruby
Query.offset(0)
```
```deno
Query.offset(0)
```
```php
Query::offset(0)
```
```swift
Query.offset(0)
```
```http
{"method":"offset","values":[0]}
```
{% /multicode %}

### Cursor after {% #cursor-after %}

Places the cursor after the specified resource ID. Used for [pagination](/docs/products/databases/pagination).

{% multicode %}
```client-web
Query.cursorAfter("62a7...f620")
```
```client-flutter
Query.cursorAfter("62a7...f620")
```
```python
Query.cursor_after("62a7...f620")
```
```ruby
Query.cursor_after("62a7...f620")
```
```deno
Query.cursorAfter("62a7...f620")
```
```php
Query::cursorAfter("62a7...f620")
```
```swift
Query.cursorAfter("62a7...f620")
```
```http
{"method":"cursorAfter","values":["62a7...f620"]}
```
{% /multicode %}

### Cursor before {% #cursor-before %}

Places the cursor before the specified resource ID. Used for [pagination](/docs/products/databases/pagination).

{% multicode %}
```client-web
Query.cursorBefore("62a7...a600")
```
```client-flutter
Query.cursorBefore("62a7...a600")
```
```python
Query.cursor_before("62a7...a600")
```
```ruby
Query.cursor_before("62a7...a600")
```
```deno
Query.cursorBefore("62a7...a600")
```
```php
Query::cursorBefore("62a7...a600")
```
```swift
Query.cursorBefore("62a7...a600")
```
```http
{"method":"cursorBefore","values":["62a7...a600"]}
```
{% /multicode %}

# Complex queries {% #complex-queries %}

You can create complex queries by combining AND and OR operations. For example, to find items that are either books under $20 or magazines under $10:

{% multicode %}
```client-web
const results = await tablesDB.listRows(
    '<DATABASE_ID>',
    '<TABLE_ID>',
    [
        Query.or([
            Query.and([
                Query.equal('category', ['books']),
                Query.lessThan('price', 20)
            ]),
            Query.and([
                Query.equal('category', ['magazines']),
                Query.lessThan('price', 10)
            ])
        ])
    ]
);
```
```client-flutter
final results = await tablesDB.listRows(
    '<DATABASE_ID>',
    '<TABLE_ID>',
    [
        Query.or([
            Query.and([
                Query.equal('category', ['books']),
                Query.lessThan('price', 20)
            ]),
            Query.and([
                Query.equal('category', ['magazines']),
                Query.lessThan('price', 10)
            ])
        ])
    ]
);
```
```python
results = tablesDB.list_rows(
    database_id='<DATABASE_ID>',
    table_id='<TABLE_ID>',
    queries=[
        Query.or_queries([
            Query.and_queries([
                Query.equal('category', ['books']),
                Query.less_than('price', 20)
            ]),
            Query.and_queries([
                Query.equal('category', ['magazines']),
                Query.less_than('price', 10)
            ])
        ])
    ]
)
```
```http
{"method":"or","values":[{"method":"and","values":[{"method":"equal","column":"category","values":["books"]},{"method":"lessThan","column":"price","values":[20]}]},{"method":"and","values":[{"method":"equal","column":"category","values":["magazines"]},{"method":"lessThan","column":"price","values":[10]}]}]}
```
{% /multicode %}

This example demonstrates how to combine `OR` and `AND` operations. The query uses `Query.or()` to match either condition: books under $20 OR magazines under $10.
Each condition within the OR is composed of two AND conditions - one for the category and one for the price threshold. The database will return rows that match either of these combined conditions.

