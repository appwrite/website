---
layout: article
title: Multi-factor authentication
description: Add multiple layers of authentication to your applications powered by Appwrite Authentication.
---

Multi-factor authentication (MFA) greatly increases the security of your apps by adding additional layers of protection.
When Multifactor authentication is enabled, a malicious actor needs to compromise multiple authentication factors to gain unauthorized access.
Appwrite Authentication lets you easily implement MFA in your apps, letting you build more securely and quickly.

{% info title="Looking for MFA for your Console account?" %}
This page covers MFA for your app's end-users. 
If you are looking for MFA for your Appwrite Console account, please refer to the [Console MFA page](/docs/advanced/security/mfa).
{% /info %}

Appwrite currently allows two factors of authentication. More factors of authentication will be available soon.

Here are the steps to implement MFA in your application.

{% section #enable-mfa step=1 title="Enable MFA on an account" %}
You can enable MFA on your account by calling `account.updateMFA()`.
You will need to have added more than 1 factors of authentication to an account before
the MFA is enforced.

Initialize your Appwrite SDK's `Client` and `Account`.
{% multicode %}
```js
import { Client, Account } from "appwrite";

const client = new Client();

const account = new Account(client);

client
    .setEndpoint('https://cloud.appwrite.io/v1') // Your API Endpoint
    .setProject('<YOUR_PROJECT_ID>') // Your project ID
;
```
```dart
import 'package:appwrite/appwrite.dart';

void main() {                        // Init SDK
  Client client = Client();
  Account account = Account(client);

  client
    .setEndpoint('https://cloud.appwrite.io/v1') // Your API Endpoint
    .setProject('<YOUR_PROJECT_ID>')             // Your project ID
  ;
}
```

```swift
import Appwrite

let client = Client()
    .setEndpoint("https://cloud.appwrite.io/v1") // Your API Endpoint
    .setProject("<YOUR_PROJECT_ID>") // Your project ID

let account = Account(client)
```

```kotlin
import io.appwrite.Client
import io.appwrite.services.Account

val client = Client(context)
    .setEndpoint("https://cloud.appwrite.io/v1") // Your API Endpoint
    .setProject("<YOUR_PROJECT_ID>") // Your project ID

val account = Account(client)
```
{% /multicode %}


{% multicode %}
```js
const promise = account.updateMFA(true);

promise.then(function (response) {
    console.log(response);           // Success
}, function (error) {
    console.log(error);              // Failure
});
```

```dart
Future result = account.updateMFA(
    mfa: false,
);

result
.then((response) {
    print(response);
}).catchError((error) {
    print(error.response);
});
```
```swift
let user = try await account.updateMFA(
  mfa: xfalse
)
```
```kotlin
val response = account.updateMFA(
    mfa = false
)
```
{% /multicode %}
{% /section %}
{% section #init-login step=2 title="Initialize login" %}
Begin your login flow with the default authentication method used by your app, for example, email password.
{% multicode %}
```js
const promise = account.createEmailPasswordSession(
        'email@example.com',         // email
        'password'                   // password
    );

promise.then(function (response) {
    console.log(response);           // Success
}, function (error) {
    console.log(error);              // Failure
});
```

```dart                       // Init SDK
Future result = account.createEmailPasswordSession(
email: 'email@example.com',
password: 'password',
);

result
.then((response) {
    print(response);
}).catchError((error) {
    print(error.response);
});
```
```swift
let session = try await account.createEmailPasswordSession(
  email: "email@example.com",
  password: "password"
)
```
```kotlin
val response = account.createEmailPasswordSession(
    email = "email@example.com",
    password = "password"
)
```
{% /multicode %}
{% /section %}
{% section #check-for-2fa step=3 title="Check for multi-factor" %}
Upon successful login in the first authentication step, check the status of the login by calling `account.get()`.
If more than one factors are required, you will the error `user_more_factors_required`.
{% multicode %}
```js
const promise = account.get();

promise.then(function (response) {
    console.log(response);           // Success
}, function (error) {
    console.log(error);              // Failure
    if (error.type === `user_more_factors_required`){
        // redirect to perform MFA
    }
    else {
        // handle other errors
    }
});
```

```dart
Future result = account.get();

result
.then((response) {
    print(response);
}).catchError((error) {
    print(error.response);
    if (error.type == 'user_more_factors_required') {
    // redirect to perform MFA
    } else {
    // handle other errors
    }
});
```
```swift
do {
    let user = try await account.get()
} catch let error as AppwriteException {
    print(error.message)
    if error.type == "user_more_factors_required" {
        // redirect to perform MFA
    } else {
        // handle other errors
    }
}
```
```kotlin
try {
    val response = account.get()
    println(response)
} catch (error: AppwriteException) {
    println(error.message)
    if (error.type == "user_more_factors_required") {
        // redirect to perform MFA
    } else {
        // handle other errors
    }
}
```
{% /multicode %}
{% /section %}
{% section #list-provider step=4 title="List provider" %}
You can check which providers are enabled for an account using `account.listProviders()`.
The returned object will be formatted like this.

```js
{
    totp: true, // time-based one-time password
    email: false, // email
    phone: true // phone
}
```

{% multicode %}
```js
const promise = account.listFactors();

promise.then(function (response) {
    console.log(response);           // Success
    // redirect based on providers returned.
}, function (error) {
    console.log(error);              // Failure
});
```
```dart
Future result = account.listFactors();

result
.then((response) {
    print(response);
    // redirect based on providers returned.
}).catchError((error) {
    print(error.response);
});
```

```swift
let mfaFactors = try await account.listFactors()
```

```kotlin
val response = account.listFactors()
```
{% /multicode %}

{% /section %}
{% section #create-challenge step=5 title="Create challenge" %}
Based on the providers available, initialize an additional auth step.
Calling these methods will send a challenge to the user.
You will need to save the challenge ID to complete the challenge in a later step.
{% multicode %}
```js
// "totp" for authenticator app challenge
// "email" for email challenge
// "phone" for SMS challenge
const promise = account.createChallenge(
        'phone'                       // factor
    );

promise.then(function (response) {
    console.log(response);           // Success
    let challengeId = response.$id; 
}, function (error) {
    console.log(error);              // Failure
});

```

```dart
Future result = account.createChallenge(
factor: 'phone',
);

result
.then((response) {
    print(response);
    var challengeId = response.$id;
}).catchError((error) {
    print(error.response);
});
```

```swift
let mfaChallenge = try await account.createChallenge(
  factor: "phone"
)
let challengeId = mfaChallenge.id
```

```kotlin
val response = account.createChallenge(
    factor = "phone"
)
val challengeId = response.id
```
{% /multicode %}

{% /section %}
{% section #complete-challenge step=6 title="Complete challenge" %}
Once the user receives the challenge code, you can pass the code back to Appwrite to complete the challenge.
{% multicode %}
```js
const promise = account.updateChallenge(
        '[CHALLENGE_ID]',            // challengeId
        '[OTP]'                      // otp
    );
```

```dart
Future result = account.updateChallenge(
challengeId: '[CHALLENGE_ID]',
otp: '[OTP]',
);

result
.then((response) {
    print(response);
}).catchError((error) {
    print(error.response);
});
```

```kotlin
let result = try await account.updateChallenge(
  challengeId: "[CHALLENGE_ID]",
  otp: "[OTP]"
)
```

```swift
val response = account.updateChallenge(
    challengeId = "[CHALLENGE_ID]",
    otp = "[OTP]"
)
```
{% /multicode %}
{% /section %}