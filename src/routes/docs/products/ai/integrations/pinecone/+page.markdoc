---
layout: article
title: Integrating Pinecone and Appwrite
description: Learn how to integrate Pinecone into your Appwrite project.
difficulty: beginner
readtime: 15
back: /docs/products/ai/computer-vision
---

Pinecone is a vector database that allows you to store and query high-dimensional vectors. It is a great tool for building recommendation systems, search engines, and more. In this tutorial, we'll show you how to integrate Pinecone into your Appwrite project.

Inside an Appwrite Function, we'll create a method to that indexes an Appwrite collection into Pinecone. We'll also create a method to query the Pinecone index and return the results.

# Prerequisites {% #prerequisites %}

- An Appwrite project
- An Appwrite collection
- An OpenAI API key
- A Pinecone API key
- A Pinecone index

{% section #step-1 step=1 title="Create new function" %}
Head to the [Appwrite Console](https://cloud.appwrite.io/console) then click on **Functions** in the left sidebar and then click on the **Create Function** button.

{% only_dark %}
![Create function screen](/images/docs/functions/dark/template.png)
{% /only_dark %}

{% only_light %}
![Create function screen](/images/docs/functions/template.png)
{% /only_light %}

1. In the Appwrite Console's sidebar, click **Functions**.
2. Click **Create function**.
3. Under **Connect Git repository**, select your provider.
4. After connecting to GitHub, under **Quick start**, select the **Node.js** starter template.
5. In the **Variables** step, tick the box to **Generate API key on completion**.
6. Follow the step-by-step wizard and create the function.
{% /section %}

{% section #step-2 step=2 title="Add Pinecone SDK" %}
Once your function is created, navigate to the freshly created repository and clone it to your local machine.

Install the `@pinecone-database/pinecone` package to simplify the process of interacting with the Pinecone API.

```bash
npm install @pinecone-database/pinecone
```
{% /section %}

{% section #step-3 step=3 title="Create utility functions" %}
For this example, the function will be able to take both `GET` and `POST` requests.

Create a new `src/utils.js` file with the following code:

```js
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const staticFolder = path.join(__dirname, '../static');

export function getStaticFile(fileName) {
  return fs.readFileSync(path.join(staticFolder, fileName)).toString();
}
```

Add the following utility function to the `src/utils.js` file to check if all required fields are present in an object:

```js
export function throwIfMissing(obj, keys) {
  const missing = [];
  for (let key of keys) {
    if (!(key in obj) || !obj[key]) {
      missing.push(key);
    }
  }
  if (missing.length > 0) {
    throw new Error(`Missing required fields: ${missing.join(', ')}`);
  }
}
```

We will use these utility functions in the next steps.
{% /section %}

{% section #step-4 step=4 title="Handle GET request" %}
Write the `GET` request handler in the `src/main.js` file. This handler will return a static HTML page you'll create later.

```js
import { getStaticFile, throwIfMissing } from './utils.js';

export default async ({ req, res, error }) => {
  throwIfMissing(process.env, [
    'APPWRITE_API_KEY',
    'APPWRITE_DATABASE_ID',
    'APPWRITE_COLLECTION_ID',
    'PINECONE_API_KEY',
    'PINECONE_INDEX_ID',
    'OPENAI_API_KEY',
  ]);

  if (req.method === 'GET') {
    const html = getStaticFile('index.html');
    return res.send(html, 200, { 'Content-Type': 'text/html; charset=utf-8' });
  }

  if (req.method !== 'POST') {
    return res.json({ ok: false, error: 'Method not allowed' }, 405);
  }
};
```

Breaking down the code:

1. The `throwIfMissing` function is used to check if all required environment variables are present.
1. The function checks if the request method is `GET` and returns the static HTML page.
1. If the request method is not `GET` or `POST`, it returns an error.
{% /section %}

{% section #step-5 step=5 title="Create web page" %}
Now create a HTML web page that the function will serve. Create a new `static` folder in the root of your project and add an `index.html` with some HTML boilerplate:

```html
<!doctype html>
<html lang="en">
</html>
```

Within the `<html>` tag, Add a `<head>` tag that will define the style and scripts.

```html
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pinecone Demo</title>

    <script src="https://unpkg.com/meilisearch@0.34.1"></script>
    <script src="https://unpkg.com/alpinejs" defer></script>

    <link rel="stylesheet" href="https://unpkg.com/@appwrite.io/pink" />
    <link rel="stylesheet" href="https://unpkg.com/@appwrite.io/pink-icons" />
</head>
  
```

And after the `</head>` tag add this `<body>` which will contain the actual form:

```html
<body>
    <main class="main-content">
        <div class="top-cover u-padding-block-end-56">
        <div class="container">
            <div
            class="u-flex u-gap-16 u-flex-justify-center u-margin-block-start-16"
            >
            <h1 class="heading-level-1">Pinecone Demo</h1>
            <code class="u-un-break-text"></code>
            </div>
            <p
            class="body-text-1 u-normal u-margin-block-start-8"
            style="max-width: 50rem"
            >
            Use this demo to verify that the sync between Appwrite Databases and
            Pinecone was successful. Search your Pinecone vector database using
            the input below.
            </p>
        </div>
        </div>
        <div
            class="container u-margin-block-start-negative-56"
            x-data="{ search: '', results: [ ] }"
            x-init="$watch('search', async (value) => { results = await onSearch(value) })"
        >
        <div class="card u-flex u-gap-24 u-flex-vertical">
            <div id="searchbox">
            <div
                class="input-text-wrapper is-with-end-button u-width-full-line"
            >
                <input x-model="search" type="search" placeholder="Search" />
                <div class="icon-search" aria-hidden="true"></div>
            </div>
            </div>
            <div id="hits" class="u-flex u-flex-vertical u-gap-12">
            <template x-for="result in results">
                <div class="card">
                <pre x-text="JSON.stringify(result, null, '\t')"></pre>
                </div>
            </template>
            </div>
        </div>
        </div>
    </main>
    <script>
        window.onSearch = async function (prompt) {
            const response = await fetch('/search', {
                method: 'POST',
                body: JSON.stringify({ prompt }),
                headers: {
                'Content-Type': 'application/json',
                },
            });
            return response.matches;
        };
    </script>
</body>
```

This will render a form that will submit your search query to the function and display the results.

{% /section %}

{% section #step-6 step=6 title="Setup SDKs" %}
Now after serving the HTML page, add methods necessary to integrate with the OpenAI and Pinecone APIs

First, import `openai` and `@pinecone-database/pinecone` at the top of the `main.js` file:

```js
import { Pinecone } from '@pinecone-database/pinecone';
import { OpenAI } from 'openai';
```

Add code to initialize the Pinecone and OpenAI clients at the end of request handler in the `main.js` file:

```js
const pinecone = new Pinecone({
    apiKey: process.env.PINECONE_API_KEY,
});
const index = pinecone.index(process.env.PINECONE_INDEX_ID);

const openai = new OpenAI({
    piKey: process.env.OPENAI_API_KEY,
});
```

Breaking down the code:
1. The `Pinecone` class is initialized to interact with the Pinecone API.
2. The index is retrieved from Pinecone using the `PINECONE_INDEX_ID` environment variable.
3. The `OpenAI` class is intiialized to interact with the OpenAI API.

{% /section %}

{% section #step-7 step=7 title="Handle search requests" %}

To handle the search requests, add the following code to the end of the request handler in the `main.js` file:

```js
if (req.path === '/search') {
    const queryEmbedding = await openai.embeddings.create({
        model: 'text-embedding-ada-002',
        input: req.body.prompt,
    });

    const searchResults = await index.query({
        vector: queryEmbedding.data[0].embedding,
        topK: 5,
    });

    return res.json(searchResults);
}
```

Breaking down the code:
1. The function sends the prompt to the OpenAI API to get the embedding.
2. The embedding vector is sent to Pinecone to search for the top 5 most similiar vectors.
3. The function returns the search results.

{% /section %}

{% section #step-8 step=8 title="Handle indexing requests" %}

Before search requests can be handled, the Appwrite collection needs to be indexed into the Pinecone index. Add the following code to the end of the request handler in the `main.js` file:

```js
const client = new Client()
  .setEndpoint(
    process.env.APPWRITE_ENDPOINT ?? 'https://cloud.appwrite.io/v1'
  )
  .setProject(process.env.APPWRITE_FUNCTION_PROJECT_ID)
  .setKey(process.env.APPWRITE_API_KEY);

const databases = new Databases(client);
```

Now the Appwrite client is initialized to interact with the Appwrite API. 
Add the following code to the end of the request handler in the `main.js` file:

```js
let cursor = null;
do {
  const queries = [Query.limit(100)];

  if (cursor) {
    queries.push(Query.cursorAfter(cursor));
  }

  const { documents } = await databases.listDocuments(
    process.env.APPWRITE_DATABASE_ID,
    process.env.APPWRITE_COLLECTION_ID,
    queries
  );

  if (documents.length === 0) {
    log(`No more documents found.`);
    break;
  }

  cursor = documents[documents.length - 1].$id;

  const embeddings = await Promise.all(
    documents.map(async (document) => {
      const record = await openai.embeddings.create({
        model: 'text-embedding-ada-002',
        input: JSON.stringify(document),
      });
      return {
        id: document.$id,
        values: record.data[0].embedding,
        metadata: document,
      };
    })
  );

  await index.upsert(embeddings);

  log(`Synced ${documents.length} documents.`);
} while (cursor);

log('Sync finished.');

return res.send('Sync finished.', 200);
```

Breaking down the code:
1. The function initializes the Appwrite client to interact with the Appwrite API.
2. The function retrieves all documents from the Appwrite collection.
3. The function sends each document to the OpenAI API to get the embedding.
4. The function sends the embeddings to the Pinecone index.
5. The function logs the number of documents synced.

{% /section %}

{% section #step-8 step=8 title="Test the function" %}
Now that the function is deployed, test it by visiting the function URL in your browser.
This should show the UI created earlier and to test it, write a search query and click the submit button. After a brief moment you should see the matched results.

<!--- TODO add screenshots --->
{% /section %}
