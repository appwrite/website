---
layout: article
title: Integrating ElevenLabs into Appwrite
description: Learn how to integrate ElevenLabs into your Appwrite project.
difficulty: beginner
readtime: 15
back: /docs/products/ai/audio-processing
---

Integrating ElevenLabs into your Appwrite project is simple. This tutorial will guide you through the process of setting up the ElevenLabs API and integrating it into your Appwrite project.

## Prerequisites
- An Appwrite Project
- An ElevenLabs API Key

{% section #step-1 step=1 title="Create new function" %}
Head to the [Appwrite Console](https://cloud.appwrite.io/console) then click on **Functions** in the left sidebar and then click on the **Create Function** button.

{% only_dark %}
![Create function screen](/images/docs/functions/dark/template.png)
{% /only_dark %}
{% only_light %}
![Create function screen](/images/docs/functions/template.png)
{% /only_light %}

1. In the Appwrite Console's sidebar, click **Functions**.
2. Click **Create function**.
3. Under **Connect Git repository**, select your provider.
4. After connecting to GitHub, under **Quick start**, select the **Node.js** starter template.
5. In the **Variables** step, tick the box to **Generate API key on completion**.
6. Follow the step-by-step wizard and create the function.
{% /section %}

{% section #step-2 step=2 title="Add Fetch" %}
Once your function is created, navigate to the freshly created repository and either clone it to your local machine or launch a GitHub Codespace.

Since we're going to be making requests to the ElevenLabs API and fetch isn't included in the current NodeJS 18 Runtime, we're going to install the `node-fetch` package.
We're also going to install the `node-appwrite` package so we can upload the generated audio file to Appwrite Storage.
```bash
npm install node-fetch node-appwrite
```
{% /section %}

{% section #step-3 step=3 title="Create utility functions" %}
For our example, our function will be able to take both `GET` and `POST` requests.

For the `GET` request we will return a static HTML page we'll write later that will use AlpineJS to make a `POST` request to our function and the `POST` request will return the ElevenLabs audio stored in Appwrite Storage.

To begin with we will write the code to return the static HTML page, to do this we'll create a new `src/utils.js` file with the following code:

```js
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const staticFolder = path.join(__dirname, '../static');

/**
 * Returns the contents of a file in the static folder
 * @param {string} fileName
 * @returns {string} Contents of static/{fileName}
 */
export function getStaticFile(fileName) {
  return fs.readFileSync(path.join(staticFolder, fileName)).toString();
}
```

By separating the `getStaticFile()` function into a `utils.js` file, we can easily reuse this function in other parts of our function if we extend on top of this.

While we're at it, we're also going to create a `throwIfMissing()` function in the same file which we'll use later to validate body and environment variables:

```js
/**
 * Throws an error if any of the keys are missing from the object
 * @param {*} obj
 * @param {string[]} keys
 * @throws {Error}
 */
export function throwIfMissing(obj, keys) {
  const missing = [];
  for (let key of keys) {
    if (!(key in obj) || !obj[key]) {
      missing.push(key);
    }
  }
  if (missing.length > 0) {
    throw new Error(`Missing required fields: ${missing.join(', ')}`);
  }
}
```

{% /section %}

{% section #step-4 step=4 title="Create HTML File" %}
Next, we'll create the static HTML file that we'll return. First we're going to create some HTML Boilerplate in `static/index.html`:

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Perplexity Demo</title>
  </head>
  <body></body>
</html>
```

To keep this tutorial simple, we're going to use [AlpineJS](https://alpinejs.dev/) as our JS Framework of choice.
To do this we're going to a new script tag to our html file's head tag:

```html
<script src="//unpkg.com/alpinejs" defer></script>
```

Finally to provide some styling we're going to add use [Pink Design](https://pink.appwrite.io), our CSS Framework. Feel free to use any CSS Framework you like though.

Add the following link tags to your HTML file's head tag:

```html
<link rel="stylesheet" href="https://unpkg.com/@appwrite.io/pink" />
<link rel="stylesheet" href="https://unpkg.com/@appwrite.io/pink-icons" />
```

This completes the boilerplate for our HTML file, we'll continue to add the rest of the HTML and AlpineJS code in the next steps.
{% /section %}

{% section #step-5 step=5 title="Serving HTML" %}
Now that we have our HTML file, we need to serve it from our function. To do this we'll add the following code to our `main.js` file:

```js
import { getStaticFile, throwIfMissing } from './utils.js';

export default async ({ req, res, error }) => {
  throwIfMissing(process.env, [
    "ELEVENLABS_API_KEY",
    "APPWRITE_API_KEY",
    "APPWRITE_BUCKET_ID",
  ]);

  if (req.method === 'GET') {
    return res.send(getStaticFile('index.html'), 200, {
      'Content-Type': 'text/html; charset=utf-8',
    });
  }
};
```

Notice we also added a check to ensure that the `ELEVENLABS_API_KEY`, `APPWRITE_API_KEY` and `APPWRITE_BUCKET_ID` environment variables is set.
{% /section %}

{% section #step-6 step=6 title="Use the ElevenLabs API" %}
Now that we have our HTML file being served, we can begin to add the code that will talk to the ElevenLabs API.

First, we're going to import Fetch at the top of our `main.js` file and a bunch of Appwrite helper functions:

```js
import { Client, Storage, ID, InputFile, Permission, Role } from "node-appwrite";
import fetch from "node-fetch";
```

Next after we serve the HTML, we're going to add code to validate the body of the request and initialise the Appwrite SDK:
```js
const endpoint = process.env.APPWRITE_ENDPOINT || "https://cloud.appwrite.io/v1"

const client = new Client()
  .setEndpoint()
  .setProject(process.env.APPWRITE_FUNCTION_PROJECT_ID)
  .setKey(process.env.APPWRITE_API_KEY);

try {
  throwIfMissing(req.body, ["text"]);
} catch (err) {
  return res.json({ ok: false, error: err.message }, 400);
}
```

Finally, we're going to add the code to make the request to the ElevenLabs API and return the response:

```js
let body = {
  accent: req.body.accent || "british",
  accent_strength: 1.0,
  age: req.body.age || "young",
  gender: req.body.gender || "female",
  text: req.body.text,
};

const resp = await fetch(
  "https://api.elevenlabs.io/v1/voice-generation/generate-voice",
  {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "xi-api-key": process.env.ELEVENLABS_API_KEY,
    },
    body: JSON.stringify(body),
  },
);

if (resp.status !== 200) {
  error(await resp.text());
  return res.json({ ok: false, error: "Failed to generate audio" }, 500);
}
```

This code will send our prompt to the the ElevenLabs API and return the audio into a blob,
additionally it'll also catch any errors we could encounter and reports them for easy debugging.
{% /section %}

{% section #step-7 step=7 title="Storing Audio in Appwrite Storage" %}

Now we have our audio file, we can store it in Appwrite Storage for easy retrieval later:

```js
const storage = new Storage(client);

let file = await storage.createFile(
  process.env.APPWRITE_BUCKET_ID,
  ID.unique(),
  InputFile.fromBlob(await resp.blob(), "audio.mp3"),
  [Permission.read(Role.any())],
);
```

So we can instantly show it to the user, we're going to calculate the download URL and return it in the response:

```js
const url = `${endpoint}/storage/buckets/${process.env.APPWRITE_BUCKET_ID}/files/${file.$id}/view?project=${process.env.APPWRITE_FUNCTION_PROJECT_ID}`;

return res.json({ ok: true, response: url });
```

This should finish up our function, we can now move on to the next step where we'll add the code to make our page interactive.
{% /section %}

{% section #step-8 step=8 title="Making our page interactive" %}
Now we have a working API that can talk to the ElevenLabs API, we can begin to add the code to make our page interactive.

First we're going to add a new script tag to our head tag that will handle our HTTP Request:

```html
<script>
  async function onSubmit(prompt) {
    const response = await fetch('/', {
      method: 'POST',
      body: JSON.stringify({ text: prompt }),
      headers: {
        'Content-Type': 'application/json',
      },
    });

    const json = await response.json();

    if (!json.ok || json.error) {
      alert(json.error);
    }

    return json.response;
  }
</script>
```
This will send a POST request to our function with the prompt as the body and return the completion.

First we're going to add a header to our page using Pink Design, add the following inside your `<body>` tags:

```html
<main class="main-content">
  <div class="top-cover u-padding-block-end-56">
    <div class="container">
      <div
        class="u-flex u-gap-16 u-flex-justify-center u-margin-block-start-16"
      >
        <h1 class="heading-level-1">ElevenLabs Demo</h1>
        <code class="u-un-break-text"></code>
      </div>
      <p
        class="body-text-1 u-normal u-margin-block-start-8"
        style="max-width: 50rem"
      >
        Use this page to test your implementation with ElevenLabs. Enter
        text and receive the model output as a response.
      </p>
    </div>
  </div>
</main>
```

After this we're going to add the actual form that will allow us to make requests to our API, within the `<main>` tag and after the existing `<div>` add the following:

```html
<div class="container u-margin-block-start-negative-56"
  x-data="{ prompt: '', response: '', loading: false }">
  <div class="card u-flex u-gap-24 u-flex-vertical">
    <div class="u-flex u-cross-center u-gap-8">
      <div
        class="input-text-wrapper is-with-end-button u-width-full-line"
      >
        <input x-model="prompt" type="search" placeholder="Question" />
        <div class="icon-search" aria-hidden="true"></div>
      </div>

      <button
        class="button"
        x-bind:disabled="loading"
        x-on:click="async () => { loading = true; response = ''; try { response = await onSubmit(prompt) } catch(err) { console.error(err); } finally { loading = false; } }"
      >
        <span class="text">Submit</span>
      </button>
    </div>
    <template x-if="response">
      <div class="u-flex u-flex-vertical u-gap-12">
        <div class="u-flex u-flex-vertical u-gap-12 card">
          <div class="u-flex u-gap-12">
            <h5 class="eyebrow-heading-2">Output:</h5>
          </div>

          <audio x-bind:src="response" controls></audio>
        </div>
      </div>
    </template>
  </div>
</div>
```

This code might seem quite complex if you've never used AlpineJS so we'll break it down a bit:

1. `x-data="{ prompt: '', response: '', loading: false }"` defines our state for the application.
2. `x-model="prompt"` is a two-way binding that will bind the value of the input to the `prompt` variable which will update our state for us.
3. `x-bind:disabled="loading"` will disable the button if the `loading` state variable is true.
4. The `x-on:click` binds an event listener that will call the `onSubmit` function we defined earlier within `<script>` when the button is clicked. This function will set the `loading` state to true, clear the `answer` variable, and then call the `onSubmit` function. If the function fails, it will log the error to the console and set the `loading` state back to false.
5. `x-if="response"` will only render the completion if the `answer` variable is not empty.
6. Finally, `x-bind:src="response"` will bind the url of the audio file to the `response` variable.

Putting all this together gives us a nice form that will allow us to send prompts to our API and allow us to play back the audio URL we recieve.
{% /section %}

{% section #step-9 step=9 title="Deploy the function" %}
With the function complete, we can now deploy it to Appwrite.
{% partial file="deploy-function.md" /%}
{% /section %}

{% section #step-10 step=10 title="Test our function" %}
Now that our function is deployed, we can test it by visiting the function URL in our browser.
This should show the UI we created earlier and to test it we can write a prompt and click the submit button, after a brief moment you should see the audio appear below the input.

![Testing the function](/images/docs/ai/integrations/elevenlabs/demo.png)
{% /section %}

{% section #step-11 step=11 title="Conclusion" %}
In this tutorial, we've created a simple web page that allows us to interact with the ElevenLabs API using Appwrite Functions. We've learned how to create a function that interacts with an external API, upload audio to storage, how to deploy it to Appwrite, and how to create an interactive web page that uses the function.


We look forward to seeing what you build with Appwrite and ElevenLabs!
{% /section %}
