---
layout: article
title: Integrating Replicate into Appwrite
description: Learn how to integrate Replicate into your Appwrite project.
difficulty: beginner
readtime: 15
back: /docs/products/ai/computer-vision
---

Integrating Replicate into your Appwrite project is simple. This tutorial will guide you through the process of setting up the Replicate API and integrating it into your Appwrite project.

## Prerequisites
- An Appwrite Project
- Replicate API Key

{% section #step-1 step=1 title="Create new function" %}
Head to the [Appwrite Console](https://cloud.appwrite.io/console) then click on **Functions** in the left sidebar and then click on the **Create Function** button.

{% only_dark %}
![Create function screen](/images/docs/functions/dark/template.png)
{% /only_dark %}
{% only_light %}
![Create function screen](/images/docs/functions/template.png)
{% /only_light %}

1. In the Appwrite Console's sidebar, click **Functions**.
2. Click **Create function**.
3. Under **Connect Git repository**, select your provider.
4. After connecting to GitHub, under **Quick start**, select the **Node.js** starter template.
5. In the **Variables** step, tick the box to **Generate API key on completion**.
6. Follow the step-by-step wizard and create the function.
{% /section %}

{% section #step-2 step=2 title="Add Replicate SDK" %}
Once your function is created, navigate to the freshly created repository and either clone it to your local machine or launch a GitHub Codespace.

Once you have the repository open, you can install the Replicate by running the following command in your terminal:

```bash
npm install replicate
```
{% /section %}

{% section #step-3 step=3 title="Create utility functions" %}
For our example, our function will be able to take both `GET` and `POST` requests.

For the `GET` request we will return a static HTML page which we'll write later that will use AlpineJS to make a `POST` request to our function.
Meanwhile, our `POST` request will use the Replicate SDK to make a request to the Replicate API.

To begin with we will write the code to return the static HTML page, to do this we'll create a new `src/utils.js` file with the following code:

```js
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const staticFolder = path.join(__dirname, '../static');

/**
 * Returns the contents of a file in the static folder
 * @param {string} fileName
 * @returns {string} Contents of static/{fileName}
 */
export function getStaticFile(fileName) {
  return fs.readFileSync(path.join(staticFolder, fileName)).toString();
}
```

By separating the `getStaticFile()` function into a `utils.js` file, we can easily reuse this function in other parts of our function if we extend on top of this.

While we're at it, we're also going to create a `throwIfMissing()` function in the same file which we'll use later to validate body and environment variables:

```js
/**
 * Throws an error if any of the keys are missing from the object
 * @param {*} obj
 * @param {string[]} keys
 * @throws {Error}
 */
export function throwIfMissing(obj, keys) {
  const missing = [];
  for (let key of keys) {
    if (!(key in obj) || !obj[key]) {
      missing.push(key);
    }
  }
  if (missing.length > 0) {
    throw new Error(`Missing required fields: ${missing.join(', ')}`);
  }
}
```

{% /section %}

{% section #step-4 step=4 title="Create HTML File" %}
Next, we'll create the static HTML file that we'll return. First we're going to create some HTML Boilerplate in `static/index.html`:

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Replicate Demo</title>
  </head>
  <body></body>
</html>
```

To keep this tutorial simple, we're going to use [AlpineJS](https://alpinejs.dev/) as our JS Framework of choice.
To do this we're going to a new script tag to our html file's head tag:

```html
<script src="//unpkg.com/alpinejs" defer></script>
```

Finally to provide some styling we're going to add use [Pink Design](https://pink.appwrite.io), our CSS Framework. Feel free to use any CSS Framework you like though.

Add the following link tags to your HTML file's head tag:

```html
<link rel="stylesheet" href="https://unpkg.com/@appwrite.io/pink" />
<link rel="stylesheet" href="https://unpkg.com/@appwrite.io/pink-icons" />
```

This completes the boilerplate for our HTML file, we'll continue to add the rest of the HTML and AlpineJS code in the next steps.
{% /section %}

{% section #step-5 step=5 title="Serving HTML" %}
Now that we have our HTML file, we need to serve it from our function. To do this we'll add the following code to our `main.js` file:

```js
import { getStaticFile, throwIfMissing } from './utils.js';

export default async ({ req, res, error }) => {
  throwIfMissing(process.env, ['REPLICATE_API_KEY']);

  if (req.method === 'GET') {
    return res.send(getStaticFile('index.html'), 200, {
      'Content-Type': 'text/html; charset=utf-8',
    });
  }
};
```

This function so far will serve out HTML File but will also throw an error if the `REPLICATE_API_KEY` environment variable is missing.
{% /section %}

{% section #step-6 step=6 title="Use the Replicate API" %}
Now that we have our HTML file being served, we can begin to add the code that will talk to the replicate API.

First, we're going to import the Replicate SDK at the top of our `main.js` file:

```js
import Replicate from "replicate";
```

Next after we serve the HTML we're going to add code to validate the body of the request, define our models and initialise the Replicate SDK:
```js
const models = {
  'audio': 'meta/musicgen:b05b1dff1d8c6dc63d14b0cdb42135378dcb87f6373b0d3d341ede46e59e2b38',
  'text': 'meta/llama-2-70b-chat',
  'image': 'stability-ai/sdxl:39ed52f2a78e934b3ba6e2a89f5b1c712de7dfea535525255b1aa35c5565e08b'
};

try {
  throwIfMissing(req.body, ['prompt', 'type']);
} catch (err) {
  return res.json({ ok: false, error: err.message }, 400);
}

if (req.body.type !== 'audio' && req.body.type !== 'text' && req.body.type !== 'image') {
  return res.json({ ok: false, error: 'Invalid type' }, 400);
}

const replicate = new Replicate();
```
In this example we're going to be using meta's musicgen and llama2 70b models for music and text generation while using Stability AI's SDXL model for image generation. You can find more models on the [Replicate explore page](https://replicate.com/explore).

Next we're going to add some per model configurations:

```js
let request = {
  input: {
    prompt: req.body.prompt,
  }
};

// Allows you to tinker parameters for individual output types
switch (req.body.type) {
  case 'audio':
    request.input = {
      ...request.input,
      length: 30,
    }
  break;
  case 'text':
    request.input = {
      ...request.input,
      max_new_tokens: 512,
    }
  break;
  case 'image':
    request.input = {
      ...request.input,
      width: 512,
      height: 512,
      negative_prompt: "deformed, noisy, blurry, distorted",
    }
  break;
};
```
This allows us to individually configure each of the models we're using, feel free to play with this configuration to get the best results for your use case.

Finally with our request built we can call the replicate API and generate a prediction:
```js
let response;

try {
  response = await replicate.run(models[req.body.type], request);
} catch (err) {
  error(err);

  return res.json({ ok: false, error: 'Failed to run model' }, 500);
}

if (req.body.type === 'image') {
  response = response[0]
} else if (req.body.type === 'text') {
  response = response.join('');
}

return res.json({ ok: true, response, type: req.body.type }, 200);
```

We've also added some error handling and response formatting to make it easier to work with the API.
{% /section %}

{% section #step-7 step=7 title="Making our page interactive" %}
Now we have a working API, we can begin to add the code to make our page interactive.

First we're going to add a new script tag to our head tag that will handle our HTTP Request:

```html
<script>
    async function onSubmit(prompt, type) {
      const response = await fetch('/', {
        method: 'POST',
        body: JSON.stringify({ prompt, type }),
        headers: {
          'Content-Type': 'application/json',
        },
      });

      const json = await response.json();

      if (!json.ok || json.error) {
        alert(json.error);
      }

      return json;
    }
</script>
```
This will send a POST request to our function with the prompt and type as the body and return the completion.

For our actual markup we're first going to add a header to our page using Pink Design, add the following inside your `<body>` tags:

```html
<main class="main-content">
  <div class="top-cover u-padding-block-end-56">
    <div class="container">
      <div
        class="u-flex u-gap-16 u-flex-justify-center u-margin-block-start-16"
      >
        <h1 class="heading-level-1">Replicate Demo</h1>
        <code class="u-un-break-text"></code>
      </div>
      <p
        class="body-text-1 u-normal u-margin-block-start-8"
        style="max-width: 50rem"
      >
        Use this page to test your implementation with Replicate. Enter
        text and receive the model output as a response.
      </p>
    </div>
  </div>
</main>
```

After this we're going to add the actual form that will allow us to make requests to our API, within the `<main>` tag and after the existing `<div>` add the following:

```html
<div class="container u-margin-block-start-negative-56"
  x-data="{ type: 'text', prompt: '', answer: {type: '', answer: ''}, loading: false }">
  <div class="card u-flex u-gap-24 u-flex-vertical">
    <div class="u-flex u-cross-center u-gap-8">
      <div class="input-text-wrapper is-with-end-button u-width-full-line">
        <input x-model="prompt" type="search" placeholder="Prompt" />
        <div class="icon-search" aria-hidden="true"></div>
      </div>
      <div class="select u-width-140">
        <select x-model="type">
          <option value="text">Text</option>
          <option value="image">Image</option>
          <option value="audio">Audio</option>
        </select>
        <span class="icon-cheveron-down" aria-hidden="true"></span>
      </div>

      <button class="button" x-bind:disabled="loading"
        x-on:click="async () => { loading = true; answer = {type: '', answer: ''}; try { answer = await onSubmit(prompt, type) } catch(err) { console.error(err); } finally { loading = false; } }">
        <span class="text">Generate</span>
      </button>
    </div>
    <template x-if="answer.type">
      <div class="u-flex u-flex-vertical u-gap-12">
        <div class="u-flex u-flex-vertical u-gap-12 card">
          <div class="u-flex u-gap-12">
            <h5 class="eyebrow-heading-2">Result:</h5>
          </div>
          <template x-if="answer.type === 'image'" class="u-flex u-gap-12">
            <img class="u-max-width-400" x-bind:src="answer.response" alt="Replicate output" />
          </template>
          <template x-if="answer.type === 'audio'" class="u-flex u-gap-12">
            <audio x-bind:src="answer.response" controls></audio>
          </template>
          <template x-if="answer.type === 'text'" class="u-flex u-gap-12">
            <p class="u-color-text-gray" x-text="answer.response"></p>
          </template>
        </div>
      </div>
    </template>
  </div>
</div>
```

This code might seem quite complex if you've never used AlpineJS so we'll break it down a bit:

1. `x-data="{ prompt: '', answer: '', loading: false }"` defines our state for the application.
2. `x-model="prompt"` and `x-model="type"` is a two-way binding that will bind the value of the input and select to the `prompt` and `type` variables which will use later to post our form.
3. `x-bind:disabled="loading"` will disable the button if the `loading` state variable is true.
4. The `x-on:click` binds an event listener that will call the `onSubmit` function we defined earlier within `<script>` when the button is clicked. This function will set the `loading` state to true, clear the `answer` variable, and then call the `onSubmit` function. If the function fails, it will log the error to the console and set the `loading` state back to false.
5. `x-if="answer"` will only render the completion if the `answer` variable is not empty.
6. We use multiple `x-if` conditions to render the completion based on the type of completion we receive from the API using `x-text` and `x-bind` respectively.

Putting all this together gives us a nice form that will allow us to send prompts to our API and display the completion.
{% /section %}

{% section #step-8 step=8 title="Deploy the function" %}
With the function complete, we can now deploy it to Appwrite.
{% partial file="deploy-function.md" /%}
{% /section %}

{% section #step-9 step=9 title="Test our function" %}
Now that our function is deployed, we can test it by visiting the function URL in our browser.
This should show the UI we created earlier and to test it we can write a prompt and click the submit button, after a brief moment you should see the completion appear below the input.

![Testing the function](/images/docs/ai/integrations/replicate/demo.png)
{% /section %}

{% section #step-10 step=10 title="Conclusion" %}
In this tutorial, we've created a simple web page that allows us to interact with the Replicate API using Appwrite Functions. We've learned how to create a function that interacts with an external API, how to deploy it to Appwrite, and how to create an interactive web page that uses the function.

To build on it further, you could add more features such as the ability to select the model, more styling or to make it more of a chatbot interface by utilising Appwrite's Databases to store the conversation history.

We look forward to seeing what you build with Appwrite and Replicate!
{% /section %}
