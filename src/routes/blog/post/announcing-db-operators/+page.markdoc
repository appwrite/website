---
layout: post
title: "Announcing DB operators: Update multiple fields without fetching the entire row"
description: With Appwrite's DB operators, make precise, atomic updates across fields in a single call. No redundant reads or race conditions.
date: 2025-11-04
cover: /images/blog/announcing-db-operators/cover.png
timeToRead: 5
author: jake-barnby
category: announcement
featured: false
---
If you've ever needed to update a single field in a row: increment a counter, add a tag, or adjust an expiry date, you probably had to read the full row, make the change locally, and then write the entire row back.

While that's fine at a small scale, it becomes a real bottleneck once you have concurrent updates or high-traffic workloads. Each read–modify–write cycle adds latency, increases bandwidth usage, and opens up the risk of **lost updates** when multiple writes overlap.

To make this faster and safer, Appwrite is introducing **DB operators.** A new way to perform **inline, atomic updates** directly at the storage layer. Instead of sending new values, you describe the action: increment, append, replace, or adjust. Appwrite applies that instruction directly in the database, performing the change in one atomic step and keeping your data consistent without extra work in your code.

# Fixing the read–modify–write problem

DB operators eliminate the friction that comes with traditional updates. There's no need to fetch an entire row just to bump a counter, tweak a tag list, or roll a date forward. You send only the operation, and Appwrite applies it in one atomic step.

This approach removes bulky payloads, avoids race conditions caused by read–modify–write loops, and reduces the number of network round-trips. The result is simpler update logic and more predictable performance, especially under concurrent workloads.

# Currently supported operators

The following operators are available, grouped by field type. Each operator updates the given column atomically on the server.

- **Numeric operators**

Perform arithmetic operations directly on numeric fields without reading the row first.

`increment`, `decrement`, `multiply`, `divide`, `modulo`, `power`

- **Array operators**

Edit lists or tags in place: append, remove, or modify array items atomically.

`arrayAppend`, `arrayPrepend`, `arrayInsert`, `arrayRemove`, `arrayUnique`, `arrayIntersect`, `arrayDiff`, `arrayFilter`

- **String operators**

Make lightweight text changes without rewriting the whole row.

`stringConcat`, `stringReplace`

- **Date operators**

Update time-based fields for lifecycle events or scheduling logic.

`dateAddDays`, `dateSubDays`, `dateSetNow`

- **Boolean operators**

Toggle boolean values directly without reading or rewriting the entire record.

`toggle`

# Example

Here's an example of how you can append a value to an array field.

```js
import { Client, TablesDB, Operator } from "appwrite";

const client = new Client()
    .setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
    .setProject('<YOUR_PROJECT_ID>');

const tablesDB = new TablesDB(client);

const result = await tablesDB.updateRow({
    databaseId: "<DATABASE_ID>",
    tableId: "<TABLE_ID>",
    rowId: "<ROW_ID>",
    data: {
	    letters: Operator.arrayAppend(['c'])
    }
});
```

# Key things to know

Here are some important elements you need to know before you go ahead and start using the DB operators

- **Atomic by field:** Every operation happens safely at the storage layer, no lost updates, even under heavy concurrency.
- **Multi-field updates:** Apply multiple operations across different fields in a single atomic call.
- **Type-safe SDK methods:** All operators are exposed through typed SDK methods for clarity and safety.
- **Transaction-ready:** Operators can be staged and committed alongside other database actions for consistent updates.
- **Composable:** Combine different operator types (numeric, array, string, date) in one update for more complex logic.

# Immediate benefits

- **Always consistent:** Updates stay correct even when multiple clients write to the same row at once.
- **Lower latency & bandwidth:** One round trip, no need to fetch or rewrite entire rows.
- **Cleaner code:** One call with clear intent instead of managing read–modify–write logic.
- **Composable ops:** Apply multiple field updates in a single atomic operation.

# Conclusion

DB operators are built for developers who need fast, reliable, and precise data updates:  whether you're handling high-concurrency workloads like counters and usage tracking, managing dynamic content like tags or arrays, keeping data clean with string updates, or automating lifecycle logic such as expiry and renewals.

They simplify your workflow, cut down unnecessary reads, and keep your data consistent even under load.

The feature is available now on Appwrite Cloud and will be coming soon to self-hosted deployments.

# More resources

- [Read the documentation to get started](/docs/products/databases/db-operators)
- [Announcing Transactions API: Reliable multi-record writes across tables](/blog/post/announcing-transactions-api)
- [Announcing Atomic numeric operations](/blog/post/announcing-atomic-numeric-operations)
