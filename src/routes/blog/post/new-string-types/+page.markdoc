---
layout: post
title: "Introducing new string column types for Appwrite Databases"
description: Appwrite Databases now supports varchar, text, mediumtext, and longtext column types, giving you explicit control over how string data is stored and indexed. The legacy string type is now deprecated.
date: 2026-02-10
cover: /images/blog/announcing-screenshots-api/cover.png
timeToRead: 5
author: atharva
category: announcement
featured: false
---

Until now, Appwrite offered a single `string` column type that internally switched between four different storage types based on the size you specified. This meant you had no visibility into how your data was actually stored, how it could be indexed, or why certain size limits existed.

Today, we're introducing four explicit string column types: `varchar`, `text`, `mediumtext`, and `longtext`.

# The new string types

Each type has a clear purpose and a defined maximum size:

| Type         | Max characters    | Indexing                                      |
|--------------|-------------------|-----------------------------------------------|
| `varchar`    | 16,383            | Fully indexable if size < 768                 |
| `text`       | 16,383            | Prefix indexing only                          |
| `mediumtext` | 4,194,303         | Prefix indexing only                          |
| `longtext`   | 1,073,741,823     | Prefix indexing only                          |

## Varchar vs Text

Both `varchar` and `text` share the same maximum size, but they behave differently under the hood.

`varchar` is stored inline in the table row and counts towards the 64KB maximum row size shared across all columns. If the size is less than 768 characters, the column can be fully indexed, making it ideal for short strings you need to query, sort, or filter on, like names, slugs, or identifiers.

`text` is stored off-page, with only a 20-byte pointer kept in the table row. This means it doesn't eat into your row size budget, but it can only be indexed with prefix or functional indexes. Use `text` when you need string storage without full indexing, like descriptions or notes.

## Mediumtext and Longtext

For larger content, `mediumtext` supports up to ~4 million characters and `longtext` up to ~1 billion characters. Both are stored off-page and support prefix indexing only. These are the right choice for storing things like article bodies, logs, or serialized data.

# Why we made this change

We regularly dogfood Appwrite in our own projects to find areas we can improve. While building [Imagine](https://imagine.dev), our AI-powered builder for web apps, which uses Appwrite under the hood for out-of-the-box server functionality, we quickly noticed how hard it is for AI models to reason about the `string` column type. Here's what we found.

The legacy `string` type was a catch-all. It would internally switch between four different storage types based on the size you specified. While this was convenient for developers, it created a real problem for AI agents:

- **Opaque sizing decisions.** The `string` type required you to specify a size, but gave no indication of how that size mapped to actual storage. A model had no way to know that `size: 10000` would produce a `VARCHAR(10000)` stored inline, while `size: 20000` would switch to a `TEXT` column stored off-page.
- **Easy to hit row width limits.** Appwrite uses MariaDB under the hood, which has a fixed 64KB maximum row width. Varchar columns are stored inline and count towards that limit. If an AI agent created a `string` column with `size: 10000` for something like blog content, that single column would consume a large chunk of the row budget, limiting how many other columns the table could have.
- **Not just an AI problem.** We've been observing this same issue in the community. Developers run into row width limits without understanding why, because the storage behavior of `string` was invisible.

We saw this firsthand with Imagine. Imagine runs an Appwrite Cloud agent that provisions database resources on your behalf using the Appwrite CLI and `appwrite.json` as the schema. The agent is trained to build sophisticated architectures, and it would easily create just enough string columns to hit the row width limit.

We could have solved this with better prompting, but that would only fix Imagine. We wanted to improve the experience for everyone, whether you're using AI tooling, the Console, or the SDKs directly. With explicit types, an AI model now naturally picks `longtext` for something like blog content, which is stored off-page and doesn't consume row space.

# Using the new types

Here's how to create a table with the new types using the Node.js SDK:

```server-nodejs
const sdk = require('node-appwrite');

const client = new sdk.Client()
    .setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
    .setProject('<PROJECT_ID>')
    .setKey('<API_KEY>');

const tablesDB = new sdk.TablesDB(client);

await tablesDB.createTable({
    databaseId: '<DATABASE_ID>',
    tableId: '<TABLE_ID>',
    name: 'articles',
    columns: [
        {
            key: 'title',
            type: 'varchar',
            size: 255,
            required: true
        },
        {
            key: 'summary',
            type: 'text',
            required: false
        },
        {
            key: 'body',
            type: 'mediumtext',
            required: false
        },
        {
            key: 'raw_data',
            type: 'longtext',
            required: false
        }
    ]
});
```

# Deprecation of the string type

The `string` column type is now deprecated. It will continue to work for existing columns, but we recommend using the explicit types for all new columns going forward.

Previously, `string` would internally pick between `varchar`, `text`, `mediumtext`, and `longtext` based on the size you specified, without giving you any indication of which one was being used. The new types remove that ambiguity entirely.

# Available now

These changes are live on Appwrite Cloud. You can start using the new column types today through the Console, SDKs, and CLI.

# More resources

- [Read the Tables documentation](/docs/products/databases/tables)
- [Announcing Transactions API: Reliable multi-record writes across tables](/blog/post/announcing-transactions-api)
